// Tableau 3.2.3.1.-B - Usages des groupes A, B3, C, D et F3 - Sans gicleurs
const tableauGroupesAB3CDF3 = {
    10: {
        "< 3:1": [0, 8, 10, 18, 29, 46, 91, 100],
        "3:1 à 10:1": [0, 8, 12, 21, 33, 50, 96, 100],
        "> 10:1": [0, 11, 18, 32, 48, 68, 100]
    },
    15: {
        "< 3:1": [0, 7, 9, 14, 22, 33, 63, 100],
        "3:1 à 10:1": [0, 8, 10, 17, 25, 37, 67, 100],
        "> 10:1": [0, 10, 15, 26, 39, 53, 87, 100]
    },
    20: {
        "< 3:1": [0, 7, 9, 12, 18, 26, 49, 81, 100],
        "3:1 à 10:1": [0, 8, 10, 15, 21, 30, 53, 85, 100],
        "> 10:1": [0, 9, 14, 23, 33, 45, 72, 100]
    },
    25: {
        "< 3:1": [0, 7, 8, 11, 16, 23, 41, 66, 98, 100],
        "3:1 à 10:1": [0, 8, 9, 13, 19, 26, 45, 70, 100],
        "> 10:1": [0, 9, 13, 21, 30, 39, 62, 90, 100]
    },
    30: {
        "< 3:1": [0, 7, 8, 11, 15, 20, 35, 56, 83, 100],
        "3:1 à 10:1": [0, 7, 9, 12, 17, 23, 39, 61, 88, 100],
        "> 10:1": [0, 8, 12, 19, 27, 36, 56, 79, 100]
    },
    40: {
        "< 3:1": [0, 7, 8, 10, 13, 17, 28, 44, 64, 89, 100],
        "3:1 à 10:1": [0, 7, 8, 11, 15, 20, 32, 48, 69, 93, 100],
        "> 10:1": [0, 8, 11, 17, 24, 31, 47, 66, 88, 100]
    },
    50: {
        "< 3:1": [0, 7, 8, 9, 12, 15, 24, 37, 53, 72, 96, 100],
        "3:1 à 10:1": [0, 7, 8, 10, 14, 18, 28, 41, 57, 77, 100],
        "> 10:1": [0, 8, 10, 15, 21, 28, 41, 57, 76, 97, 100]
    },
    60: {
        "< 3:1": [0, 7, 8, 9, 11, 14, 21, 32, 45, 62, 81, 100],
        "3:1 à 10:1": [0, 7, 8, 10, 13, 16, 25, 36, 49, 66, 85, 100],
        "> 10:1": [0, 8, 10, 14, 20, 25, 38, 51, 67, 85, 100]
    },
    80: {
        "< 3:1": [0, 7, 7, 8, 10, 12, 18, 26, 36, 48, 62, 79, 98, 100],
        "3:1 à 10:1": [0, 7, 8, 9, 11, 14, 21, 29, 40, 52, 67, 84, 100],
        "> 10:1": [0, 8, 9, 13, 17, 22, 32, 44, 56, 70, 86, 100]
    },
    100: {
        "< 3:1": [0, 7, 7, 8, 9, 11, 16, 22, 30, 40, 51, 65, 80, 97, 100],
        "3:1 à 10:1": [0, 7, 8, 9, 11, 13, 18, 25, 34, 44, 56, 69, 84, 100],
        "> 10:1": [0, 7, 9, 12, 16, 20, 29, 39, 49, 61, 74, 89, 100]
    },
    150: {
        "< 3:1": [0, 7, 7, 8, 9, 10, 13, 17, 22, 29, 37, 46, 56, 67, 79, 93, 100],
        "3:1 à 10:1": [0, 7, 7, 8, 10, 11, 15, 20, 26, 33, 41, 50, 60, 71, 84, 97, 100],
        "> 10:1": [0, 7, 8, 11, 13, 17, 24, 31, 39, 48, 57, 68, 79, 91, 100]
    },
    250: {
        "< 3:1": [0, 7, 7, 7, 8, 9, 10, 13, 16, 20, 25, 30, 36, 43, 51, 59, 68, 87, 100],
        "3:1 à 10:1": [0, 7, 7, 8, 9, 10, 12, 15, 19, 24, 28, 34, 40, 47, 55, 63, 72, 92, 100],
        "> 10:1": [0, 7, 8, 9, 11, 14, 19, 24, 30, 36, 43, 50, 57, 65, 73, 82, 92, 100]
    },
    350: {
        "< 3:1": [0, 7, 7, 7, 8, 8, 9, 11, 14, 16, 20, 24, 28, 33, 38, 44, 50, 64, 81, 99, 100],
        "3:1 à 10:1": [0, 7, 7, 8, 8, 9, 11, 13, 16, 19, 23, 27, 32, 37, 42, 48, 55, 69, 85, 100],
        "> 10:1": [0, 7, 8, 9, 10, 12, 16, 21, 25, 30, 36, 41, 47, 53, 59, 66, 73, 88, 100]
    },
    500: {
        "< 3:1": [0, 7, 7, 7, 7, 8, 9, 10, 12, 14, 16, 19, 22, 25, 29, 33, 37, 47, 59, 71, 100],
        "3:1 à 10:1": [0, 7, 7, 7, 8, 8, 10, 12, 14, 16, 19, 22, 25, 29, 33, 37, 41, 52, 63, 76, 100],
        "> 10:1": [0, 7, 7, 8, 9, 11, 14, 18, 22, 25, 30, 34, 38, 43, 48, 53, 58, 70, 82, 96, 100]
    },
    1000: {
        "< 3:1": [0, 7, 7, 7, 7, 7, 8, 9, 9, 10, 12, 13, 14, 16, 18, 20, 22, 27, 33, 39, 58, 82, 100],
        "3:1 à 10:1": [0, 7, 7, 7, 7, 8, 9, 10, 11, 12, 14, 15, 17, 19, 21, 23, 26, 31, 37, 43, 63, 86, 100],
        "> 10:1": [0, 7, 7, 8, 8, 9, 11, 13, 16, 19, 21, 24, 27, 30, 33, 36, 39, 46, 53, 60, 82, 100]
    },
    2000: {
        "< 3:1": [0, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 10, 11, 12, 13, 14, 15, 17, 20, 23, 33, 44, 58, 74, 93, 100],
        "3:1 à 10:1": [0, 7, 7, 7, 7, 7, 8, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 23, 27, 37, 49, 63, 79, 97, 100],
        "> 10:1": [0, 7, 7, 7, 8, 8, 9, 11, 12, 14, 16, 18, 19, 21, 23, 25, 27, 32, 36, 40, 53, 66, 82, 99, 100]
    }
};

// Tableau 3.2.3.1.-C - Usages des groupes E, F1 et F2 - Sans gicleurs
const tableauGroupesEF1F2 = {
    10: {
        "< 3:1": [0, 4, 5, 9, 15, 23, 46, 77, 100],
        "3:1 à 10:1": [0, 4, 6, 10, 17, 25, 48, 79, 100],
        "> 10:1": [0, 5, 9, 16, 24, 34, 58, 91, 100]
    },
    15: {
        "< 3:1": [0, 4, 5, 7, 11, 16, 32, 53, 79, 100],
        "3:1 à 10:1": [0, 4, 5, 8, 13, 18, 34, 55, 82, 100],
        "> 10:1": [0, 5, 8, 13, 19, 26, 43, 66, 93, 100]
    },
    20: {
        "< 3:1": [0, 4, 4, 6, 9, 13, 25, 40, 61, 85, 100],
        "3:1 à 10:1": [0, 4, 5, 7, 11, 15, 27, 43, 63, 87, 100],
        "> 10:1": [0, 5, 7, 11, 17, 22, 36, 53, 74, 99, 100]
    },
    25: {
        "< 3:1": [0, 4, 4, 6, 8, 11, 20, 33, 49, 69, 92, 100],
        "3:1 à 10:1": [0, 4, 5, 7, 9, 13, 22, 35, 51, 71, 94, 100],
        "> 10:1": [0, 4, 6, 10, 15, 20, 31, 45, 62, 82, 100]
    },
    30: {
        "< 3:1": [0, 4, 4, 5, 7, 10, 18, 28, 42, 58, 77, 100],
        "3:1 à 10:1": [0, 4, 4, 6, 9, 12, 20, 30, 44, 60, 80, 100],
        "> 10:1": [0, 4, 6, 10, 14, 18, 28, 40, 54, 71, 91, 100]
    },
    40: {
        "< 3:1": [0, 4, 4, 5, 6, 8, 14, 22, 32, 44, 59, 76, 94, 100],
        "3:1 à 10:1": [0, 4, 4, 6, 8, 10, 16, 24, 34, 47, 61, 78, 97, 100],
        "> 10:1": [0, 4, 5, 8, 12, 15, 23, 33, 44, 57, 72, 89, 100]
    },
    50: {
        "< 3:1": [0, 4, 4, 5, 6, 7, 12, 18, 26, 36, 48, 61, 76, 93, 100],
        "3:1 à 10:1": [0, 4, 4, 5, 7, 9, 14, 20, 29, 38, 50, 63, 79, 95, 100],
        "> 10:1": [0, 4, 5, 8, 11, 14, 21, 29, 38, 48, 61, 74, 90, 100]
    },
    60: {
        "< 3:1": [0, 4, 4, 4, 5, 7, 11, 16, 23, 31, 40, 52, 64, 78, 94, 100],
        "3:1 à 10:1": [0, 4, 4, 5, 6, 8, 12, 18, 25, 33, 43, 54, 66, 81, 96, 100],
        "> 10:1": [0, 4, 5, 7, 10, 13, 19, 26, 34, 43, 53, 64, 77, 92, 100]
    },
    80: {
        "< 3:1": [0, 4, 4, 4, 5, 6, 9, 13, 18, 24, 31, 40, 49, 60, 71, 84, 98, 100],
        "3:1 à 10:1": [0, 4, 4, 5, 6, 7, 10, 15, 20, 26, 33, 42, 51, 62, 74, 86, 100],
        "> 10:1": [0, 4, 5, 6, 9, 11, 16, 22, 28, 35, 43, 52, 62, 73, 85, 98, 100]
    },
    100: {
        "< 3:1": [0, 4, 4, 4, 5, 5, 8, 11, 15, 20, 26, 32, 40, 48, 58, 68, 79, 100],
        "3:1 à 10:1": [0, 4, 4, 4, 5, 6, 9, 13, 17, 22, 28, 35, 42, 51, 60, 70, 81, 100],
        "> 10:1": [0, 4, 4, 6, 8, 10, 14, 19, 25, 31, 37, 44, 52, 61, 71, 81, 92, 100]
    },
    150: {
        "< 3:1": [0, 4, 4, 4, 4, 5, 6, 8, 11, 14, 18, 23, 28, 33, 40, 46, 54, 70, 89, 100],
        "3:1 à 10:1": [0, 4, 4, 4, 5, 6, 8, 10, 13, 16, 20, 25, 30, 36, 42, 49, 56, 73, 92, 100],
        "> 10:1": [0, 4, 4, 5, 7, 8, 12, 16, 20, 24, 29, 34, 39, 46, 52, 59, 67, 84, 100]
    },
    250: {
        "< 3:1": [0, 4, 4, 4, 4, 4, 5, 7, 8, 10, 12, 15, 18, 22, 25, 29, 34, 44, 55, 68, 100],
        "3:1 à 10:1": [0, 4, 4, 4, 4, 5, 6, 8, 10, 12, 14, 17, 20, 24, 27, 32, 36, 46, 57, 70, 100],
      "> 10:1": [0, 4, 4, 5, 6, 7, 9, 12, 15, 18, 21, 25, 28, 32, 37, 41, 46, 56, 68, 81, 100]
    },
    350: {
        "< 3:1": [0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 10, 12, 14, 16, 19, 22, 25, 32, 40, 49, 77, 100],
        "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 5, 7, 8, 10, 12, 14, 16, 18, 21, 24, 27, 34, 43, 52, 79, 100],
        "> 10:1": [0, 4, 4, 4, 5, 6, 8, 10, 13, 15, 18, 21, 23, 26, 30, 33, 36, 44, 53, 62, 90, 100]
    },
    500: {
        "< 3:1": [0, 4, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 13, 14, 16, 19, 24, 29, 36, 55, 78, 100],
        "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 13, 14, 16, 18, 21, 26, 31, 38, 57, 80, 100],
        "> 10:1": [0, 4, 4, 4, 5, 5, 7, 9, 11, 13, 15, 17, 19, 21, 24, 26, 29, 35, 41, 48, 68, 92, 100]
    },
    1000: {
        "< 3:1": [0, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 7, 8, 9, 10, 11, 14, 16, 20, 29, 41, 55, 71, 89, 100],
        "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 22, 31, 43, 57, 73, 91, 100],
        "> 10:1": [0, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 16, 18, 20, 23, 26, 30, 41, 53, 68, 84, 100]
    },
    2000: {
        "< 3:1": [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 9, 10, 12, 16, 22, 29, 37, 46, 56, 68, 80, 94, 100],
        "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 8, 9, 10, 12, 13, 18, 24, 31, 39, 49, 59, 70, 83, 96, 100],
        "> 10:1": [0, 4, 4, 4, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 26, 33, 41, 50, 59, 70, 81, 94, 100]
    }
};

// Tableau 3.2.3.1.-D - Bâtiment protégé par gicleurs - Usages des groupes A, B, C, D et F3
const tableauAvecGicleursGroupesABCDF3 = {
    10: [0, 16, 24, 42, 66, 100],
    15: [0, 16, 20, 34, 50, 74, 100],
    20: [0, 16, 20, 30, 42, 60, 100],
    25: [0, 16, 18, 26, 38, 52, 90, 100],
    30: [0, 14, 18, 24, 34, 46, 78, 100],
    40: [0, 14, 16, 22, 30, 40, 64, 96, 100],
    50: [0, 14, 16, 20, 28, 36, 56, 82, 100],
    60: [0, 14, 16, 20, 26, 32, 50, 72, 98, 100],
    80: [0, 14, 16, 18, 22, 28, 42, 58, 80, 100],
    100: [0, 14, 16, 18, 22, 26, 36, 50, 68, 88, 100],
    150: [0, 14, 14, 16, 20, 22, 30, 40, 52, 66, 82, 100]
};

// Tableau 3.2.3.1.-E - Bâtiment protégé par gicleurs - Usages des groupes E, F1 et F2
const tableauAvecGicleursGroupesEF1F2 = {
    10: [0, 8, 12, 20, 34, 50, 96, 100],
    15: [0, 8, 10, 16, 26, 36, 68, 100],
    20: [0, 8, 10, 14, 22, 30, 54, 86, 100],
    25: [0, 8, 10, 14, 18, 26, 44, 70, 100],
    30: [0, 8, 8, 12, 18, 24, 40, 60, 88, 100],
    40: [0, 8, 8, 12, 16, 20, 32, 48, 68, 94, 100],
    50: [0, 8, 8, 10, 14, 18, 28, 40, 58, 76, 100],
    60: [0, 8, 8, 10, 12, 16, 24, 36, 50, 66, 86, 100],
    80: [0, 8, 8, 10, 12, 14, 20, 30, 40, 52, 66, 84, 100],
    100: [0, 8, 8, 8, 10, 12, 18, 26, 34, 44, 56, 70, 84, 100],
    150: [0, 8, 8, 8, 10, 12, 16, 20, 26, 32, 40, 50, 60, 72, 84, 98, 100],
    200: [0, 8, 8, 8, 8, 10, 14, 18, 22, 28, 34, 42,50, 60, 68, 80, 92, 100]
};

const limitingDistancesNoSprinklers = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70];
const limitingDistancesWithSprinklersABCDF3 = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9];
const limitingDistancesWithSprinklersEF1F2 = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
const facadeSurfaces = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 250, 350, 500, 1000, 2000];
const facadeSurfacesWithSprinklersABCDF3 = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 250, 350, 500, 1000, 2000];
const facadeSurfacesWithSprinklersEF1F2 = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 200];

// Données du Tableau 9.10.14.4-A
const tableau91014 = {
    "habitation": {
        surfaces: {
            30: [0, 7, 9, 12, 39, 88, 100, 100, 100, 100, 100, 100, 100],
            40: [0, 7, 8, 11, 32, 69, 100, 100, 100, 100, 100, 100, 100],
            50: [0, 7, 8, 10, 28, 57, 100, 100, 100, 100, 100, 100, 100],
            100: [0, 7, 8, 9, 18, 34, 56, 84, 100, 100, 100, 100, 100],
            ">100": [0, 7, 7, 8, 12, 19, 28, 40, 55, 92, 100, 100, 100]
        },
        distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0, 25.0, 30.0]
    },
    "commercial": {
        surfaces: {
            30: [0, 4, 4, 6, 20, 44, 80, 100, 100, 100, 100, 100, 100],
            40: [0, 4, 4, 6, 16, 34, 61, 97, 100, 100, 100, 100, 100],
            50: [0, 4, 4, 5, 14, 29, 50, 79, 100, 100, 100, 100, 100],
            100: [0, 4, 4, 4, 9, 17, 28, 42, 60, 100, 100, 100, 100],
            ">100": [0, 4, 4, 4, 6, 10, 14, 20, 27, 46, 70, 100, 100]
        },
        distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0, 25.0, 30.0]
    }
};

// Données du Tableau 9.10.15.4
const tableau91015 = {
    surfaces: {
        30: [0, 7, 9, 12, 39, 88, 100, 100, 100, 100, 100],
        40: [0, 7, 8, 11, 32, 69, 100, 100, 100, 100, 100],
        50: [0, 7, 8, 10, 28, 57, 100, 100, 100, 100, 100],
        100: [0, 7, 8, 9, 18, 34, 56, 84, 100, 100, 100],
        ">100": [0, 7, 7, 8, 12, 19, 28, 40, 55, 92, 100]
    },
    distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0]
};

// Fonctions de conversion entre les formats métrique et impérial
function validateImperialInput(inputValue) {
    if (!inputValue) return '';
    
    // Remplacer les apostrophes spéciales par le caractère standard '
    inputValue = inputValue.replace(/[''′]/g, "'");
    
    // Simplifier les espaces autour des caractères spéciaux
    inputValue = inputValue.replace(/\s*(['-/"])\s*/g, '$1');
    
    // Normaliser l'apostrophe suivie d'un trait d'union (6'-9) en simple apostrophe (6'9)
    inputValue = inputValue.replace(/'-/g, "'");
    
    // Ajouter un espace entre un nombre et une fraction s'il n'y en a pas
    inputValue = inputValue.replace(/(\d)(\d+\/\d+)/g, '$1 $2');
    
    return inputValue;
}

// Fonction pour passer de millimètres à une chaîne en format impérial
function metricToImperial(value, unit = "length") {
    if (!value && value !== 0) return '';
    
    // Conversion pour les longueurs (m -> pieds/pouces)
    if (unit === "length") {
        // Convertir de mètres à pouces
        const inches = value * 39.3701;
        const feet = Math.floor(inches / 12);
        const remainingInches = inches % 12;
        
        // Arrondir au 1/16 de pouce le plus proche
        const fraction = Math.round(remainingInches * 16) / 16;
        const wholePart = Math.floor(fraction);
        const fractionalPart = fraction - wholePart;
        
        let result = '';
        
        if (feet > 0) {
            result += feet + '\'';
        }
        
        if (wholePart > 0 || fractionalPart > 0) {
            if (feet > 0) result += ' ';
            
            if (wholePart > 0) {
                result += wholePart;
            }
            
            if (fractionalPart > 0) {
                // Convertir la fraction décimale en fraction
                const numerator = Math.round(fractionalPart * 16);
                const denominator = 16;
                
                // Réduire la fraction
                const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                const divisor = gcd(numerator, denominator);
                
                const simplifiedNumerator = numerator / divisor;
                const simplifiedDenominator = denominator / divisor;
                
                if (wholePart > 0) result += ' ';
                result += simplifiedNumerator + '/' + simplifiedDenominator;
            }
            
            result += '"';
        } else if (feet === 0) {
            result = '0"';
        }
        
        return result;
    }
    // Conversion pour les surfaces (m² -> pi²)
    else if (unit === "area") {
        // Convertir de m² à pi²
        const sqFeet = value * 10.7639;
        return Math.round(sqFeet) + ' pi²';
    }
    // Valeur par défaut - longueur
    else {
        return metricToImperial(value, "length");
    }
}

// Convertir des formats impériaux en métriques
function imperialToMetric(imperialValue, unit = "length") {
    if (!imperialValue && imperialValue !== 0) return null;
    
    // Conversion pour les longueurs (pieds/pouces -> m)
    if (unit === "length") {
        // Gestion de différents formats de pieds et pouces
        imperialValue = imperialValue.toString().trim();
        
        // Vérifier si c'est juste une valeur numérique (interprétée comme des pouces)
        if (/^\d+(?:\.\d+)?$/.test(imperialValue)) {
            const inches = parseFloat(imperialValue);
            return inches * 0.0254; // Convertir les pouces en mètres
        }
        
        // Format pi²
        if (/^\d+(?:\.\d+)?\s*pi(?:ed|²|2)?s?$/i.test(imperialValue)) {
            const match = imperialValue.match(/^(\d+(?:\.\d+)?)/);
            const sqFeet = parseFloat(match[1]);
            return sqFeet / 10.7639; // Convertir les pi² en m²
        }
        
        // Motifs pour capture des pieds et pouces
        const patterns = [
            /^(\d+(?:\.\d+)?)'(?:\s*)(\d+(?:\.\d+)?)?(?:\s*(?:"|in|inch|inches))?$/,  // 6'2" ou 6'2
            /^(\d+(?:\.\d+)?)(?:\s*(?:ft|feet|foot))(?:\s*)(\d+(?:\.\d+)?)?(?:\s*(?:"|in|inch|inches))?$/,  // 6 ft 2 in ou 6 ft 2
            /^(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)$/,  // 6-2
            /^(\d+(?:\.\d+)?)(?:\s+)(\d+(?:\.\d+)?)$/  // 6 2
        ];
        
        for (let pattern of patterns) {
            const match = imperialValue.match(pattern);
            if (match) {
                const feet = parseFloat(match[1]) || 0;
                const inches = match[2] ? parseFloat(match[2]) : 0;
                const totalInches = feet * 12 + inches;
                return totalInches * 0.0254; // Convertir en mètres
            }
        }
        
        // Pour les fractions (ex: "6 1/2")
        const fractionMatch = imperialValue.match(/^(\d+(?:\.\d+)?)(?:\s*)(\d+)\/(\d+)(?:\s*(?:"|in|inch|inches))?$/);
        if (fractionMatch) {
            const wholeNumber = parseFloat(fractionMatch[1]) || 0;
            const numerator = parseFloat(fractionMatch[2]);
            const denominator = parseFloat(fractionMatch[3]);
            const inches = wholeNumber + (numerator / denominator);
            return inches * 0.0254; // Convertir en mètres
        }
        
        // Pour les pieds avec fractions de pouce (ex: "6' 1/2")
        const feetWithFractionMatch = imperialValue.match(/^(\d+(?:\.\d+)?)'(?:\s*)(\d+)\/(\d+)(?:\s*(?:"|in|inch|inches))?$/);
        if (feetWithFractionMatch) {
            const feet = parseFloat(feetWithFractionMatch[1]) || 0;
            const numerator = parseFloat(feetWithFractionMatch[2]);
            const denominator = parseFloat(feetWithFractionMatch[3]);
            const totalInches = feet * 12 + (numerator / denominator);
            return totalInches * 0.0254; // Convertir en mètres
        }
        
        // Formats spéciaux comme 6'-9 1/4"
        const specialFormat = imperialValue.match(/^(\d+(?:\.\d+)?)'[-\s]*(\d+(?:\.\d+)?)(?:\s+(\d+)\/(\d+))?(?:\s*(?:"|in|inch|inches))?$/);
        if (specialFormat) {
            const feet = parseFloat(specialFormat[1]) || 0;
            const inches = parseFloat(specialFormat[2]) || 0;
            const fraction = specialFormat[3] && specialFormat[4] ? 
                parseFloat(specialFormat[3]) / parseFloat(specialFormat[4]) : 0;
            const totalInches = feet * 12 + inches + fraction;
            return totalInches * 0.0254; // Convertir en mètres
        }
        
        return null; // Format non reconnu
    }
    // Conversion pour les surfaces (pi² -> m²)
    else if (unit === "area") {
        // Normaliser les virgules en points pour les décimales
        imperialValue = imperialValue.toString().replace(',', '.');
        
        // Si c'est simplement un nombre (supposé être en pi²)
        if (/^\d+(?:\.\d+)?$/.test(imperialValue)) {
            const sqFeet = parseFloat(imperialValue);
            return sqFeet / 10.7639; // Convertir en m²
        }
        
        // Si le format est "X pi²" ou "X sq ft"
        const areaMatch = imperialValue.match(/^(\d+(?:[,.]?\d+)?)\s*(?:pi²|pi2|sq\s*ft|pi(?:ed)?s?²?)$/i);
        if (areaMatch) {
            const sqFeet = parseFloat(areaMatch[1].replace(',', '.'));
            return sqFeet / 10.7639; // Convertir en m²
        }
        
        return null; // Format non reconnu
    }
    // Valeur par défaut - longueur
    else {
        return imperialToMetric(imperialValue, "length");
    }
}

// Fonction pour calculer les dimensions automatiquement
function updateDimensions(event) {
    // Identifier quel champ vient d'être modifié
    const changedField = event.target.id;
    const isImperial = document.getElementById('measurementSystem').value === 'imperial';
    
    // Déterminer l'onglet actuel basé sur l'ID du champ
    let tabSuffix = '';
    if (changedField.includes('_cnb')) {
        tabSuffix = '_cnb';
    } else if (changedField.includes('_91014')) {
        tabSuffix = '_91014';
    } else if (changedField.includes('_91015')) {
        tabSuffix = '_91015';
    } else {
        return; // Si on ne peut pas déterminer l'onglet, on sort
    }
    
    let surfaceField, lengthField, heightField;
    let surfaceValue, lengthValue, heightValue;
    
    if (isImperial) {
        surfaceField = document.getElementById(`surface${tabSuffix}_imperial`);
        lengthField = document.getElementById(`length${tabSuffix}_imperial`);
        heightField = document.getElementById(`height${tabSuffix}_imperial`);
        
        // Convertir les valeurs impériales en métriques pour le calcul
        surfaceValue = imperialToMetric(surfaceField?.value, "area");
        lengthValue = imperialToMetric(lengthField?.value);
        heightValue = imperialToMetric(heightField?.value);
    } else {
        surfaceField = document.getElementById(`surface${tabSuffix}`);
        lengthField = document.getElementById(`length${tabSuffix}`);
        heightField = document.getElementById(`height${tabSuffix}`);
        
        surfaceValue = parseFloat(surfaceField?.value);
        lengthValue = parseFloat(lengthField?.value);
        heightValue = parseFloat(heightField?.value);
    }
    
    const metricSurfaceField = document.getElementById(`surface${tabSuffix}`);
    const metricLengthField = document.getElementById(`length${tabSuffix}`);
    const metricHeightField = document.getElementById(`height${tabSuffix}`);

    // Ne pas faire de calcul si le champ actif est vidé
    if (event.target.value === "") {
        return;
    }
    
    // Ajuster selon le champ qui a été modifié
    if (changedField === `surface${tabSuffix}` || changedField === `surface${tabSuffix}_imperial`) {
        // Si la surface est modifiée et que la longueur ou la hauteur existe, mettre à jour l'autre dimension
        if (lengthValue && lengthValue > 0) {
            // Calculer la hauteur
            const calculatedHeight = surfaceValue / lengthValue;
            
            // Mettre à jour les champs métriques
            if (metricHeightField) metricHeightField.value = calculatedHeight.toFixed(2);
            
            // Mettre à jour les champs impériaux si nécessaire
            if (isImperial && heightField) {
                heightField.value = metricToImperial(calculatedHeight);
            }
        } else if (heightValue && heightValue > 0) {
            // Calculer la longueur
            const calculatedLength = surfaceValue / heightValue;
            
            // Mettre à jour les champs métriques
            if (metricLengthField) metricLengthField.value = calculatedLength.toFixed(2);
            
            // Mettre à jour les champs impériaux si nécessaire
            if (isImperial && lengthField) {
                lengthField.value = metricToImperial(calculatedLength);
            }
        }
    } else if (changedField === `length${tabSuffix}` || changedField === `length${tabSuffix}_imperial`) {
        // Si la longueur est modifiée
        if (surfaceValue && surfaceValue > 0) {
            // Calculer la hauteur basée sur la surface
            const calculatedHeight = surfaceValue / lengthValue;
            
            // Mettre à jour les champs métriques
            if (metricHeightField) metricHeightField.value = calculatedHeight.toFixed(2);
            
            // Mettre à jour les champs impériaux si nécessaire
            if (isImperial && heightField) {
                heightField.value = metricToImperial(calculatedHeight);
            }
        } else if (heightValue && heightValue > 0) {
            // Calculer la surface
            const calculatedSurface = lengthValue * heightValue;
            
            // Mettre à jour les champs métriques
            if (metricSurfaceField) metricSurfaceField.value = calculatedSurface.toFixed(2);
            
            // Mettre à jour les champs impériaux si nécessaire
            if (isImperial && surfaceField) {
                surfaceField.value = metricToImperial(calculatedSurface, "area");
            }
        }
    } else if (changedField === `height${tabSuffix}` || changedField === `height${tabSuffix}_imperial`) {
        // Si la hauteur est modifiée
        if (surfaceValue && surfaceValue > 0) {
            // Calculer la longueur basée sur la surface
            const calculatedLength = surfaceValue / heightValue;
            
            // Mettre à jour les champs métriques
            if (metricLengthField) metricLengthField.value = calculatedLength.toFixed(2);
            
            // Mettre à jour les champs impériaux si nécessaire
            if (isImperial && lengthField) {
                lengthField.value = metricToImperial(calculatedLength);
            }
        } else if (lengthValue && lengthValue > 0) {
            // Calculer la surface
            const calculatedSurface = lengthValue * heightValue;
            
            // Mettre à jour les champs métriques
            if (metricSurfaceField) metricSurfaceField.value = calculatedSurface.toFixed(2);
            
            // Mettre à jour les champs impériaux si nécessaire
            if (isImperial && surfaceField) {
                surfaceField.value = metricToImperial(calculatedSurface, "area");
            }
        }
    }
}

// Afficher/masquer les options supplémentaires
document.addEventListener('DOMContentLoaded', function() {
    // Système de mesure
    const measurementSystem = document.getElementById('measurementSystem');
    
    measurementSystem.addEventListener('change', function() {
        const isImperial = this.value === 'imperial';
        toggleMeasurementSystem(isImperial);
        updateUnitLabels(isImperial); // Mise à jour des libellés des unités
    });
    
    // Initialiser le système de mesure au chargement
    const isImperial = measurementSystem.value === 'imperial';
    toggleMeasurementSystem(isImperial);
    updateUnitLabels(isImperial); // Mise à jour initiale des libellés des unités

    // Gestionnaires d'événements pour les checkboxes de vérification d'espacement
    document.getElementById('check_spacing_cnb').addEventListener('change', function() {
        document.getElementById('spacing_options_cnb').style.display = this.checked ? 'block' : 'none';
    });
                    
    document.getElementById('check_spacing_91014').addEventListener('change', function() {
        document.getElementById('spacing_options_91014').style.display = this.checked ? 'block' : 'none';
    });
    
    document.getElementById('check_spacing_91015').addEventListener('change', function() {
            document.getElementById('spacing_options_91015').style.display = this.checked ? 'block' : 'none';
        });
        
    // Gestionnaires d'événements pour les checkboxes de vérification des soffites
    document.getElementById('check_soffit_cnb').addEventListener('change', function() {
        document.getElementById('soffit_options_cnb').style.display = this.checked ? 'block' : 'none';
    });
        
    document.getElementById('check_soffit_91014').addEventListener('change', function() {
        document.getElementById('soffit_options_91014').style.display = this.checked ? 'block' : 'none';
    });
        
    document.getElementById('check_soffit_91015').addEventListener('change', function() {
        document.getElementById('soffit_options_91015').style.display = this.checked ? 'block' : 'none';
    });
        
    // Ajouter des écouteurs pour l'onglet CNB
const cnbInputs = document.querySelectorAll('#cnb input[type="number"], #cnb input[type="text"]');
cnbInputs.forEach(input => {
    input.addEventListener('keydown', function(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            calculateCNB();
        }
    });
});

// Ajouter des écouteurs pour l'onglet 9.10.14
const inputs91014 = document.querySelectorAll('#method91014 input[type="number"], #method91014 input[type="text"]');
inputs91014.forEach(input => {
    input.addEventListener('keydown', function(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            calculate91014();
        }
    });
});

// Ajouter des écouteurs pour l'onglet 9.10.15
const inputs91015 = document.querySelectorAll('#method91015 input[type="number"], #method91015 input[type="text"]');
inputs91015.forEach(input => {
    input.addEventListener('keydown', function(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            calculate91015();
        }
    });
});
    
    // Écouteurs d'événements pour le calcul automatique des dimensions - Onglet CNB
    document.getElementById('surface_cnb').addEventListener('input', updateDimensions);
    document.getElementById('length_cnb').addEventListener('input', updateDimensions);
    document.getElementById('height_cnb').addEventListener('input', updateDimensions);
    
    // Écouteurs pour les champs impériaux CNB
    document.getElementById('surface_cnb_imperial').addEventListener('input', updateDimensions);
    document.getElementById('length_cnb_imperial').addEventListener('input', updateDimensions);
    document.getElementById('height_cnb_imperial').addEventListener('input', updateDimensions);
    
    // Écouteurs d'événements pour le calcul automatique des dimensions - Onglet 9.10.14
    const surface91014 = document.getElementById('surface_91014');
    const length91014 = document.getElementById('length_91014');  
    const height91014 = document.getElementById('height_91014');
    const surface91014Imperial = document.getElementById('surface_91014_imperial');
    const length91014Imperial = document.getElementById('length_91014_imperial');
    const height91014Imperial = document.getElementById('height_91014_imperial');
    
    if (surface91014) surface91014.addEventListener('input', updateDimensions);
    if (length91014) length91014.addEventListener('input', updateDimensions);
    if (height91014) height91014.addEventListener('input', updateDimensions);
    if (surface91014Imperial) surface91014Imperial.addEventListener('input', updateDimensions);
    if (length91014Imperial) length91014Imperial.addEventListener('input', updateDimensions);
    if (height91014Imperial) height91014Imperial.addEventListener('input', updateDimensions);
    
    // Écouteurs d'événements pour le calcul automatique des dimensions - Onglet 9.10.15
    const surface91015 = document.getElementById('surface_91015');
    const length91015 = document.getElementById('length_91015');
    const height91015 = document.getElementById('height_91015');
    const surface91015Imperial = document.getElementById('surface_91015_imperial');
    const length91015Imperial = document.getElementById('length_91015_imperial');
    const height91015Imperial = document.getElementById('height_91015_imperial');
    
    if (surface91015) surface91015.addEventListener('input', updateDimensions);
    if (length91015) length91015.addEventListener('input', updateDimensions);
    if (height91015) height91015.addEventListener('input', updateDimensions);
    if (surface91015Imperial) surface91015Imperial.addEventListener('input', updateDimensions);
    if (length91015Imperial) length91015Imperial.addEventListener('input', updateDimensions);
    if (height91015Imperial) height91015Imperial.addEventListener('input', updateDimensions);
    
    // Liaison entre les champs métriques et impériaux
    setupMetricImperialInputPairs();

    // Ajouter des placeholders pour les champs métriques
    setMetricPlaceholders();

    // Configurer l'ajout automatique de ² pour les champs de surface impériaux
    setupAutomaticSquareSymbol();
});

// Fonction pour mettre à jour les libellés des unités en fonction du système de mesure
function updateUnitLabels(isImperial) {
    const unitLabels = document.querySelectorAll('.unit-label');
    
    unitLabels.forEach(label => {
        // Préserver les tooltips en modifiant seulement le nœud de texte
        const textNodes = Array.from(label.childNodes).filter(node => node.nodeType === 3);
        if (textNodes.length > 0) {
            let labelText = textNodes[0].nodeValue;
            
            if (isImperial) {
                // Remplacer les unités métriques par des unités impériales
                if (labelText.includes('(m)')) {
                    labelText = labelText.replace('(m)', '(pi)');
                } else if (labelText.includes('(m²)')) {
                    labelText = labelText.replace('(m²)', '(pi²)');
                }
            } else {
                // Remplacer les unités impériales par des unités métriques
                if (labelText.includes('(pi)')) {
                    labelText = labelText.replace('(pi)', '(m)');
                } else if (labelText.includes('(pi²)')) {
                    labelText = labelText.replace('(pi²)', '(m²)');
                }
            }
            
            textNodes[0].nodeValue = labelText;
        }
    });
}

// Fonction pour définir les placeholders pour les champs métriques
function setMetricPlaceholders() {
    // Onglet CNB
    document.getElementById('distance_cnb').placeholder = "Ex: 3,0";
    document.getElementById('surface_cnb').placeholder = "Ex: 100";
    document.getElementById('length_cnb').placeholder = "Ex: 10,0";
    document.getElementById('height_cnb').placeholder = "Ex: 3,0";
    document.getElementById('horizontal_spacing_cnb').placeholder = "Ex: 2,0";
    document.getElementById('vertical_spacing_cnb').placeholder = "Ex: 2,0";
    document.getElementById('soffit_distance_cnb').placeholder = "Ex: 0,5";
    document.getElementById('proposed_area_cnb').placeholder = "Ex: 50";
    
    // Onglet 9.10.14
    document.getElementById('distance_91014').placeholder = "Ex: 3,0";
    document.getElementById('surface_91014').placeholder = "Ex: 100";
    document.getElementById('horizontal_spacing_91014').placeholder = "Ex: 2,0";
    document.getElementById('vertical_spacing_91014').placeholder = "Ex: 2,0";
    document.getElementById('soffit_distance_91014').placeholder = "Ex: 0,5";
    document.getElementById('proposed_area_91014').placeholder = "Ex: 50";
    
    // Onglet 9.10.15
    document.getElementById('distance_91015').placeholder = "Ex: 3,0";
    document.getElementById('surface_91015').placeholder = "Ex: 100";
    document.getElementById('horizontal_spacing_91015').placeholder = "Ex: 2,0";
    document.getElementById('vertical_spacing_91015').placeholder = "Ex: 2,0";
    document.getElementById('soffit_distance_91015').placeholder = "Ex: 0,5";
    document.getElementById('proposed_area_91015').placeholder = "Ex: 50";
}

// Fonction pour configurer l'ajout automatique du symbole ² pour les champs de surface impériaux
function setupAutomaticSquareSymbol() {
    const surfaceFields = [
        'surface_cnb_imperial',
        'proposed_area_cnb_imperial',
        'surface_91014_imperial',
        'proposed_area_91014_imperial',
        'surface_91015_imperial',
        'proposed_area_91015_imperial'
    ];
    
    surfaceFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
            field.addEventListener('blur', function() {
                if (this.value && !this.value.includes('pi²')) {
                    // Nettoyer d'abord la valeur (enlever pi² s'il existe déjà)
                    let cleanedValue = this.value.replace(/\s*pi²\s*$/i, '').trim();
                    // Ajouter le symbole pi² si nécessaire
                    if (cleanedValue) {
                        this.value = cleanedValue + ' pi²';
                    }
                }
            });
        }
    });
}

// Fonction pour basculer entre le système métrique et impérial
function toggleMeasurementSystem(isImperial) {
    const metricInputs = document.querySelectorAll('.metric-input');
    const imperialInputs = document.querySelectorAll('.imperial-input');
    
    metricInputs.forEach(input => {
        input.style.display = isImperial ? 'none' : 'block';
    });
    
    imperialInputs.forEach(input => {
        input.style.display = isImperial ? 'block' : 'none';
    });
    
    // NOUVEAU : Convertir les valeurs existantes lors du changement de système
    if (isImperial) {
        // Convertir de métrique vers impérial
        convertExistingValuesToImperial();
    } else {
        // Convertir d'impérial vers métrique
        convertExistingValuesToMetric();
    }
    
    // Assurer que les tooltips restent visibles en mode impérial
    const tooltips = document.querySelectorAll('.unit-label .tooltip');
    tooltips.forEach(tooltip => {
        tooltip.style.display = 'inline-block';
    });
}

// NOUVELLE FONCTION : Convertir les valeurs métriques existantes vers impérial
function convertExistingValuesToImperial() {
    const conversions = [
        // Onglet CNB
        { metric: 'distance_cnb', imperial: 'distance_cnb_imperial', unit: 'length' },
        { metric: 'surface_cnb', imperial: 'surface_cnb_imperial', unit: 'area' },
        { metric: 'length_cnb', imperial: 'length_cnb_imperial', unit: 'length' },
        { metric: 'height_cnb', imperial: 'height_cnb_imperial', unit: 'length' },
        { metric: 'horizontal_spacing_cnb', imperial: 'horizontal_spacing_cnb_imperial', unit: 'length' },
        { metric: 'vertical_spacing_cnb', imperial: 'vertical_spacing_cnb_imperial', unit: 'length' },
        { metric: 'soffit_distance_cnb', imperial: 'soffit_distance_cnb_imperial', unit: 'length' },
        { metric: 'proposed_area_cnb', imperial: 'proposed_area_cnb_imperial', unit: 'area' },
        
        // Onglet 9.10.14
        { metric: 'distance_91014', imperial: 'distance_91014_imperial', unit: 'length' },
        { metric: 'surface_91014', imperial: 'surface_91014_imperial', unit: 'area' },
        { metric: 'horizontal_spacing_91014', imperial: 'horizontal_spacing_91014_imperial', unit: 'length' },
        { metric: 'vertical_spacing_91014', imperial: 'vertical_spacing_91014_imperial', unit: 'length' },
        { metric: 'soffit_distance_91014', imperial: 'soffit_distance_91014_imperial', unit: 'length' },
        { metric: 'proposed_area_91014', imperial: 'proposed_area_91014_imperial', unit: 'area' },
        
        // Onglet 9.10.15
        { metric: 'distance_91015', imperial: 'distance_91015_imperial', unit: 'length' },
        { metric: 'surface_91015', imperial: 'surface_91015_imperial', unit: 'area' },
        { metric: 'horizontal_spacing_91015', imperial: 'horizontal_spacing_91015_imperial', unit: 'length' },
        { metric: 'vertical_spacing_91015', imperial: 'vertical_spacing_91015_imperial', unit: 'length' },
        { metric: 'soffit_distance_91015', imperial: 'soffit_distance_91015_imperial', unit: 'length' },
        { metric: 'proposed_area_91015', imperial: 'proposed_area_91015_imperial', unit: 'area' }
    ];
    
    conversions.forEach(conversion => {
        const metricInput = document.getElementById(conversion.metric);
        const imperialInput = document.getElementById(conversion.imperial);
        
        if (metricInput && imperialInput && metricInput.value && metricInput.value.trim() !== '') {
            const metricValue = parseFloat(metricInput.value);
            if (!isNaN(metricValue)) {
                imperialInput.value = metricToImperial(metricValue, conversion.unit);
            }
        }
    });
}

// NOUVELLE FONCTION : Convertir les valeurs impériales existantes vers métrique
function convertExistingValuesToMetric() {
    const conversions = [
        // Onglet CNB
        { metric: 'distance_cnb', imperial: 'distance_cnb_imperial', unit: 'length' },
        { metric: 'surface_cnb', imperial: 'surface_cnb_imperial', unit: 'area' },
        { metric: 'length_cnb', imperial: 'length_cnb_imperial', unit: 'length' },
        { metric: 'height_cnb', imperial: 'height_cnb_imperial', unit: 'length' },
        { metric: 'horizontal_spacing_cnb', imperial: 'horizontal_spacing_cnb_imperial', unit: 'length' },
        { metric: 'vertical_spacing_cnb', imperial: 'vertical_spacing_cnb_imperial', unit: 'length' },
        { metric: 'soffit_distance_cnb', imperial: 'soffit_distance_cnb_imperial', unit: 'length' },
        { metric: 'proposed_area_cnb', imperial: 'proposed_area_cnb_imperial', unit: 'area' },
        
        // Onglet 9.10.14
        { metric: 'distance_91014', imperial: 'distance_91014_imperial', unit: 'length' },
        { metric: 'surface_91014', imperial: 'surface_91014_imperial', unit: 'area' },
        { metric: 'horizontal_spacing_91014', imperial: 'horizontal_spacing_91014_imperial', unit: 'length' },
        { metric: 'vertical_spacing_91014', imperial: 'vertical_spacing_91014_imperial', unit: 'length' },
        { metric: 'soffit_distance_91014', imperial: 'soffit_distance_91014_imperial', unit: 'length' },
        { metric: 'proposed_area_91014', imperial: 'proposed_area_91014_imperial', unit: 'area' },
        
        // Onglet 9.10.15
        { metric: 'distance_91015', imperial: 'distance_91015_imperial', unit: 'length' },
        { metric: 'surface_91015', imperial: 'surface_91015_imperial', unit: 'area' },
        { metric: 'horizontal_spacing_91015', imperial: 'horizontal_spacing_91015_imperial', unit: 'length' },
        { metric: 'vertical_spacing_91015', imperial: 'vertical_spacing_91015_imperial', unit: 'length' },
        { metric: 'soffit_distance_91015', imperial: 'soffit_distance_91015_imperial', unit: 'length' },
        { metric: 'proposed_area_91015', imperial: 'proposed_area_91015_imperial', unit: 'area' }
    ];
    
    conversions.forEach(conversion => {
        const metricInput = document.getElementById(conversion.metric);
        const imperialInput = document.getElementById(conversion.imperial);
        
        if (metricInput && imperialInput && imperialInput.value && imperialInput.value.trim() !== '') {
            const imperialValue = imperialToMetric(validateImperialInput(imperialInput.value), conversion.unit);
            if (imperialValue !== null) {
                metricInput.value = conversion.unit === 'area' ? imperialValue.toFixed(2) : imperialValue.toFixed(2);
            }
        }
    });
}
// Fonction pour configurer les paires d'entrées métriques/impériales
function setupMetricImperialInputPairs() {
    // Liste des paires de champs (métrique et impérial)
    const inputPairs = [
        // Onglet CNB
        { metric: 'distance_cnb', imperial: 'distance_cnb_imperial', unit: 'length' },
        { metric: 'surface_cnb', imperial: 'surface_cnb_imperial', unit: 'area' },
        { metric: 'length_cnb', imperial: 'length_cnb_imperial', unit: 'length' },
        { metric: 'height_cnb', imperial: 'height_cnb_imperial', unit: 'length' },
        { metric: 'horizontal_spacing_cnb', imperial: 'horizontal_spacing_cnb_imperial', unit: 'length' },
        { metric: 'vertical_spacing_cnb', imperial: 'vertical_spacing_cnb_imperial', unit: 'length' },
        { metric: 'soffit_distance_cnb', imperial: 'soffit_distance_cnb_imperial', unit: 'length' },
        { metric: 'proposed_area_cnb', imperial: 'proposed_area_cnb_imperial', unit: 'area' },
        
        // Onglet 9.10.14
        { metric: 'distance_91014', imperial: 'distance_91014_imperial', unit: 'length' },
        { metric: 'surface_91014', imperial: 'surface_91014_imperial', unit: 'area' },
        { metric: 'horizontal_spacing_91014', imperial: 'horizontal_spacing_91014_imperial', unit: 'length' },
        { metric: 'vertical_spacing_91014', imperial: 'vertical_spacing_91014_imperial', unit: 'length' },
        { metric: 'soffit_distance_91014', imperial: 'soffit_distance_91014_imperial', unit: 'length' },
        { metric: 'proposed_area_91014', imperial: 'proposed_area_91014_imperial', unit: 'area' },
        
        // Onglet 9.10.15
        { metric: 'distance_91015', imperial: 'distance_91015_imperial', unit: 'length' },
        { metric: 'surface_91015', imperial: 'surface_91015_imperial', unit: 'area' },
        { metric: 'horizontal_spacing_91015', imperial: 'horizontal_spacing_91015_imperial', unit: 'length' },
        { metric: 'vertical_spacing_91015', imperial: 'vertical_spacing_91015_imperial', unit: 'length' },
        { metric: 'soffit_distance_91015', imperial: 'soffit_distance_91015_imperial', unit: 'length' },
        { metric: 'proposed_area_91015', imperial: 'proposed_area_91015_imperial', unit: 'area' }
    ];
    
    // Configurer les écouteurs d'événements pour chaque paire
    inputPairs.forEach(pair => {
        const metricInput = document.getElementById(pair.metric);
        const imperialInput = document.getElementById(pair.imperial);
        
        if (metricInput && imperialInput) {
            // Métrique vers impérial
            metricInput.addEventListener('input', function() {
                const value = parseFloat(this.value);
                if (!isNaN(value)) {
                    imperialInput.value = metricToImperial(value, pair.unit);
                }
            });
            
            // Impérial vers métrique
            imperialInput.addEventListener('input', function() {
                const value = imperialToMetric(validateImperialInput(this.value), pair.unit);
                if (value !== null) {
                    metricInput.value = pair.unit === 'area' ? value.toFixed(2) : value.toFixed(2);
                }
            });
        }
    });
}

// Fonction pour déterminer la catégorie du rapport L/H
function determinerRapportLH(longueur, hauteur) {
    const rapportLH = longueur / hauteur;
    const rapportHL = hauteur / longueur;
    const maxRapport = Math.max(rapportLH, rapportHL);
    
    if (maxRapport < 3) return "< 3:1";
    if (maxRapport <= 10) return "3:1 à 10:1";
    return "> 10:1";
}

// Fonction pour trouver les valeurs encadrantes dans un tableau - MODIFIÉE pour extrapolation
function trouverValeurEncadrantes(valeur, tableau) {
    // Cas particulier: valeur exactement 0
    if (valeur === 0) {
        return { inferieure: 0, superieure: 0, extrapolation: false };
    }
    
    // Cas où la valeur est inférieure au premier élément non-nul
    let premierElementNonNul = tableau.find(e => e > 0);
    if (valeur > 0 && valeur < premierElementNonNul) {
        return { 
            inferieure: 0, 
            superieure: premierElementNonNul, 
            extrapolation: true,
            valeurExacte: valeur
        };
    }
    
    // Si la valeur est inférieure au premier élément (et non nulle)
    if (valeur <= tableau[0]) {
        return { inferieure: tableau[0], superieure: tableau[0], extrapolation: false };

   }
    
    // Si la valeur est supérieure au dernier élément
    if (valeur >= tableau[tableau.length - 1]) {
        return { inferieure: tableau[tableau.length - 1], superieure: tableau[tableau.length - 1], extrapolation: false };
    }
    
    // Rechercher les bornes encadrantes
    for (let i = 0; i < tableau.length - 1; i++) {
        if (valeur >= tableau[i] && valeur <= tableau[i + 1]) {
            return { inferieure: tableau[i], superieure: tableau[i + 1], extrapolation: false };
        }
    }
    
    // En cas d'échec (ne devrait jamais arriver si les vérifications ci-dessus sont correctes)
    return { inferieure: tableau[0], superieure: tableau[1], extrapolation: false };
}

// Fonction pour l'extrapolation des valeurs entre 0 et la première valeur non-nulle
function extrapolerPourcentage(pourcentage0, pourcentageMin, distanceMin, distanceExacte) {
    // Avec distanceExacte entre 0 et distanceMin
    // Pourcentage à 0 est généralement 0 dans les tableaux
    const pente = (pourcentageMin - pourcentage0) / distanceMin;
    const pourcentageExtrapole = pourcentage0 + (pente * distanceExacte);
    return Math.max(0, pourcentageExtrapole); // Ne jamais retourner un pourcentage négatif
}

// Fonction pour l'extrapolation des valeurs pour des surfaces inférieures au minimum du tableau
function extrapolerPourcentageSurface(pourcentageSurfaceMin, pourcentageSurfaceSupMin, surfaceMin, surfaceExacte) {
    if (surfaceExacte >= surfaceMin) return pourcentageSurfaceMin;
    
    // Tendance observée: plus la surface est petite, plus le pourcentage permis est élevé
    // On utilise une extrapolation linéaire inverse
    const ratio = surfaceMin / surfaceExacte;
    const facteur = Math.sqrt(ratio); // Facteur modérateur pour éviter une croissance trop rapide
    
    // En se basant sur la différence entre les pourcentages aux deux premières surfaces du tableau
    const tendance = (pourcentageSurfaceMin - pourcentageSurfaceSupMin) * (facteur - 1);
    return Math.min(100, pourcentageSurfaceMin + tendance); // Limitée à 100%
}

// Nouvelle fonction pour le cas spécial: FDR petite et DL >= DL minimale
function extrapolerFDRPetiteDLNormale(tableauUtilise, distanceLimitative, surfaceFacade, 
                                      surfaceMin, surfaceSupMin, distancesUtilisees, 
                                      rapportLH, avecGicleurs) {
    // Étape 1: Interpolation selon la 1ère FDR disponible
    let pourcentageEtape1;
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distancesUtilisees);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distancesUtilisees.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distancesUtilisees.indexOf(distanceSuperieure);
    
    if (distanceInferieure === distanceSuperieure) {
        // Pas besoin d'interpolation pour la distance
        if (!avecGicleurs) {
            pourcentageEtape1 = tableauUtilise[surfaceMin][rapportLH][distanceInferieureIndex];
        } else {
            pourcentageEtape1 = tableauUtilise[surfaceMin][distanceInferieureIndex];
        }
    } else {
        // Interpolation selon la distance pour la 1ère surface
        let pourcentageDistInf, pourcentageDistSup;
        if (!avecGicleurs) {
            pourcentageDistInf = tableauUtilise[surfaceMin][rapportLH][distanceInferieureIndex];
            pourcentageDistSup = tableauUtilise[surfaceMin][rapportLH][distanceSuperieureIndex];
        } else {
            pourcentageDistInf = tableauUtilise[surfaceMin][distanceInferieureIndex];
            pourcentageDistSup = tableauUtilise[surfaceMin][distanceSuperieureIndex];
        }
        
        pourcentageEtape1 = pourcentageDistInf + 
            ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
            (pourcentageDistSup - pourcentageDistInf);
    }
    
    // Étape 2: Interpolation selon la 2ème FDR disponible
    let pourcentageEtape2;
    
    if (distanceInferieure === distanceSuperieure) {
        // Pas besoin d'interpolation pour la distance
        if (!avecGicleurs) {
            pourcentageEtape2 = tableauUtilise[surfaceSupMin][rapportLH][distanceInferieureIndex];
        } else {
            pourcentageEtape2 = tableauUtilise[surfaceSupMin][distanceInferieureIndex];
        }
    } else {
        // Interpolation selon la distance pour la 2ème surface
        let pourcentageDistInf, pourcentageDistSup;
        if (!avecGicleurs) {
            pourcentageDistInf = tableauUtilise[surfaceSupMin][rapportLH][distanceInferieureIndex];
            pourcentageDistSup = tableauUtilise[surfaceSupMin][rapportLH][distanceSuperieureIndex];
        } else {
            pourcentageDistInf = tableauUtilise[surfaceSupMin][distanceInferieureIndex];
            pourcentageDistSup = tableauUtilise[surfaceSupMin][distanceSuperieureIndex];
        }
        
        pourcentageEtape2 = pourcentageDistInf + 
            ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
            (pourcentageDistSup - pourcentageDistInf);
    }
    
    // Étape 3: Extrapolation selon les résultats obtenus des deux interpolations précédentes
    const pourcentageFinal = pourcentageEtape2 + 
        ((surfaceFacade - surfaceSupMin) / (surfaceMin - surfaceSupMin)) * 
        (pourcentageEtape1 - pourcentageEtape2);
    
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction d'interpolation principale MODIFIÉE avec extrapolation
function interpolationCNB(usage, distanceLimitative, surfaceFacade, rapportLH, avecGicleurs) {
    // Déterminer les tableaux à utiliser en fonction de l'usage et de la présence de gicleurs
    let tableauUtilise, distancesUtilisees, surfacesUtilisees;
    
    if (avecGicleurs) {
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauAvecGicleursGroupesABCDF3;
            distancesUtilisees = limitingDistancesWithSprinklersABCDF3;
            surfacesUtilisees = facadeSurfacesWithSprinklersABCDF3;
        } else { // groupes_E_F1_F2
            tableauUtilise = tableauAvecGicleursGroupesEF1F2;
            distancesUtilisees = limitingDistancesWithSprinklersEF1F2;
            surfacesUtilisees = facadeSurfacesWithSprinklersEF1F2;
        }
    } else {
        distancesUtilisees = limitingDistancesNoSprinklers;
        surfacesUtilisees = facadeSurfaces;
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauGroupesAB3CDF3;
        } else { // groupes_E_F1_F2
            tableauUtilise = tableauGroupesEF1F2;
        }
    }
    
    // Vérifier si la distance limitative dépasse la plage du tableau
    if (distanceLimitative > distancesUtilisees[distancesUtilisees.length - 1]) {
        return 100; // 100% de baies non protégées autorisées
    }
    
    // Cas spécial: surface de façade < surface minimale mais DL >= DL minimale non-nulle
    const premiereDLNonNulle = distancesUtilisees.find(d => d > 0);
    if (surfaceFacade < surfacesUtilisees[0] && distanceLimitative >= premiereDLNonNulle) {
        return extrapolerFDRPetiteDLNormale(
            tableauUtilise, 
            distanceLimitative, 
            surfaceFacade, 
            surfacesUtilisees[0], 
            surfacesUtilisees[1],
            distancesUtilisees, 
            rapportLH, 
            avecGicleurs
        );
    }
    
    // ÉTAPE 0: Trouver les bornes d'encadrement pour la distance limitative
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distancesUtilisees);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distancesUtilisees.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distancesUtilisees.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Trouver les surfaces encadrantes pour la façade de rayonnement
    const surfaceFacadeMin = Math.min(surfaceFacade, surfacesUtilisees[0]); // Pour l'extrapolation
    const surfacesEncadrantes = trouverValeurEncadrantes(surfaceFacade, surfacesUtilisees);
    const surfaceInferieure = surfacesEncadrantes.inferieure;
    const surfaceSuperieure = surfacesEncadrantes.superieure;
    
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    const extrapolationSurface = surfaceFacade < surfacesUtilisees[0];
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        let pourcentageDistance0, pourcentageDistanceMin;
        
        if (extrapolationSurface) {
            // Double extrapolation (distance et surface)
            // D'abord extrapoler pour la surface minimale, puis pour la surface réelle
            
            // Pour distance = 0
            pourcentageDistance0 = 0; // Toujours 0% quand DL=0
            
            // Pour distance = min (1.2m)
            if (!avecGicleurs) {
                const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceSuperieureIndex];
                const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceSuperieureIndex];
                
                // Extrapolation pour surface plus petite avec distance min
                pourcentageDistanceMin = extrapolerPourcentageSurface(
                    pourcentageSurfMin, 
                    pourcentageSurfSupMin, 
                    surfacesUtilisees[0], 
                    surfaceFacade
                );
            } else {
                const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][distanceSuperieureIndex];
                const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][distanceSuperieureIndex];
                
                // Extrapolation pour surface plus petite avec distance min
                pourcentageDistanceMin = extrapolerPourcentageSurface(
                    pourcentageSurfMin, 
                    pourcentageSurfSupMin, 
                    surfacesUtilisees[0], 
                    surfaceFacade
                );
            }
        } else {
            // Extrapolation simple pour la distance uniquement
            pourcentageDistance0 = 0; // Toujours 0% quand DL=0
            
            if (!avecGicleurs) {
                pourcentageDistanceMin = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
            } else {
                pourcentageDistanceMin = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
            }
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        return extrapolerPourcentage(
            pourcentageDistance0, 
            pourcentageDistanceMin, 
            distanceSuperieure, 
            distanceExacte
        );
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    if (extrapolationSurface) {
        let pourcentageSurfaceMin, pourcentageSurfaceSupMin;
        
        if (!avecGicleurs) {
            pourcentageSurfaceMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceInferieureIndex];
            pourcentageSurfaceSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceInferieureIndex];
        } else {
            pourcentageSurfaceMin = tableauUtilise[surfacesUtilisees[0]][distanceInferieureIndex];
            pourcentageSurfaceSupMin = tableauUtilise[surfacesUtilisees[1]][distanceInferieureIndex];
        }
        
        return extrapolerPourcentageSurface(
            pourcentageSurfaceMin,
            pourcentageSurfaceSupMin,
            surfacesUtilisees[0],
            surfaceFacade
        );
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        return interpolationSurfaceUniquement(tableauUtilise, surfaceFacade, surfaceInferieure, 
               surfaceSuperieure, distanceInferieureIndex, rapportLH, avecGicleurs);
    }
    
    // Si les surfaces sont identiques, pas besoin d'interpolation complexe
    if (surfaceInferieure === surfaceSuperieure) {
        return interpolationDistanceUniquement(tableauUtilise, distanceLimitative, distanceInferieure, 
               distanceSuperieure, surfaceInferieure, distanceInferieureIndex, 
               distanceSuperieureIndex, rapportLH, avecGicleurs);
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    let pourcentageDistanceInferieure;
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][rapportLH][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
    } else {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    let pourcentageDistanceSuperieure;
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
    } else {
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
    }
    
    // ÉTAPE 3: Interpolation finale entre les deux résultats d'interpolation précédents
    const pourcentageFinal = pourcentageDistanceInferieure + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    // Limiter le pourcentage final entre 0 et 100
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction pour l'interpolation quand seule la surface varie (distance fixe)
function interpolationSurfaceUniquement(tableauUtilise, surfaceFacade, surfaceInferieure, 
                                      surfaceSuperieure, distanceIndex, rapportLH, avecGicleurs) {
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    const extrapolationSurface = surfaceFacade < surfaceInferieure && surfaceInferieure === Math.min(...facadeSurfaces);
    
    if (extrapolationSurface) {
        let pourcentageSurfaceMin, pourcentageSurfaceSupMin;
        
        if (!avecGicleurs) {
            pourcentageSurfaceMin = tableauUtilise[surfaceInferieure][rapportLH][distanceIndex];
            pourcentageSurfaceSupMin = tableauUtilise[Math.min(...facadeSurfaces.filter(s => s > surfaceInferieure))][rapportLH][distanceIndex];
        } else {
            pourcentageSurfaceMin = tableauUtilise[surfaceInferieure][distanceIndex];
            pourcentageSurfaceSupMin = tableauUtilise[Math.min(...facadeSurfaces.filter(s => s > surfaceInferieure))][distanceIndex];
        }
        
        return extrapolerPourcentageSurface(
            pourcentageSurfaceMin,
            pourcentageSurfaceSupMin,
            surfaceInferieure,
            surfaceFacade
        );
    }
    
    let pourcentageSurfInf, pourcentageSurfSup;
    
    if (!avecGicleurs) {
        pourcentageSurfInf = tableauUtilise[surfaceInferieure][rapportLH][distanceIndex];
        pourcentageSurfSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceIndex];
    } else {
        pourcentageSurfInf = tableauUtilise[surfaceInferieure][distanceIndex];
        pourcentageSurfSup = tableauUtilise[surfaceSuperieure][distanceIndex];
    }
    
    // Si les surfaces sont identiques, retourner directement la valeur
    if (surfaceInferieure === surfaceSuperieure) {
        return pourcentageSurfInf;
    }
    
    // Interpolation linéaire entre les surfaces - CORRIGÉE selon méthodologie
    return pourcentageSurfSup + 
        ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
        (pourcentageSurfInf - pourcentageSurfSup);
}

// Fonction pour l'interpolation quand seule la distance varie (surface unique)
function interpolationDistanceUniquement(tableauUtilise, distanceLimitative, distanceInferieure, 
                                       distanceSuperieure, surface, distanceInferieureIndex, 
                                       distanceSuperieureIndex, rapportLH, avecGicleurs) {
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    const extrapolationDistance = distanceLimitative > 0 && distanceLimitative < distanceSuperieure && distanceInferieure === 0;
    
    if (extrapolationDistance) {
        let pourcentageDistance0 = 0; // Toujours 0% quand DL=0
        let pourcentageDistanceMin;
        
        if (!avecGicleurs) {
            pourcentageDistanceMin = tableauUtilise[surface][rapportLH][distanceSuperieureIndex];
        } else {
            pourcentageDistanceMin = tableauUtilise[surface][distanceSuperieureIndex];
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        return extrapolerPourcentage(
            pourcentageDistance0,
            pourcentageDistanceMin,
            distanceSuperieure,
            distanceLimitative
        );
    }
    
    let pourcentageDistInf, pourcentageDistSup;
    
    if (!avecGicleurs) {
        pourcentageDistInf = tableauUtilise[surface][rapportLH][distanceInferieureIndex];
        pourcentageDistSup = tableauUtilise[surface][rapportLH][distanceSuperieureIndex];
    } else {
        pourcentageDistInf = tableauUtilise[surface][distanceInferieureIndex];
        pourcentageDistSup = tableauUtilise[surface][distanceSuperieureIndex];
    }
    
    // Si les distances sont identiques, retourner directement la valeur
    if (distanceInferieure === distanceSuperieure) {
        return pourcentageDistInf;
    }
    
    // Interpolation linéaire entre les distances - CORRIGÉE selon méthodologie
    return pourcentageDistInf + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistSup - pourcentageDistInf);
}

// Nouvelle fonction pour le cas spécial: FDR petite et DL >= DL minimale pour les méthodes 910x
function extrapolerFDRPetiteDLNormale910x(tableau, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    const distances = tableau.distances;
    const surfacesDisponibles = Object.keys(tableau.surfaces).filter(s => s !== ">100").map(Number);
    
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distances);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distances.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distances.indexOf(distanceSuperieure);
    
    // Étape 1: Interpolation selon la 1ère FDR disponible
    let pourcentageEtape1;
    
    if (distanceInferieure === distanceSuperieure) {
        pourcentageEtape1 = tableau.surfaces[surfacesDisponibles[0].toString()][distanceInferieureIndex];
    } else {
        const pourcentageDistInf = tableau.surfaces[surfacesDisponibles[0].toString()][distanceInferieureIndex];
        const pourcentageDistSup = tableau.surfaces[surfacesDisponibles[0].toString()][distanceSuperieureIndex];
        
        pourcentageEtape1 = pourcentageDistInf + 
            ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
            (pourcentageDistSup - pourcentageDistInf);
    }
    
    // Étape 2: Interpolation selon la 2ème FDR disponible
    let pourcentageEtape2;
    
    if (distanceInferieure === distanceSuperieure) {
        pourcentageEtape2 = tableau.surfaces[surfacesDisponibles[1].toString()][distanceInferieureIndex];
    } else {
        const pourcentageDistInf = tableau.surfaces[surfacesDisponibles[1].toString()][distanceInferieureIndex];
        const pourcentageDistSup = tableau.surfaces[surfacesDisponibles[1].toString()][distanceSuperieureIndex];
        
        pourcentageEtape2 = pourcentageDistInf + 
            ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
            (pourcentageDistSup - pourcentageDistInf);
    }
    
    // Étape 3: Extrapolation selon les résultats obtenus des deux interpolations précédentes
    let pourcentageFinal = pourcentageEtape2 + 
        ((surfaceFacade - surfacesDisponibles[1]) / (surfacesDisponibles[0] - surfacesDisponibles[1])) * 
        (pourcentageEtape1 - pourcentageEtape2);
    
    // Appliquer la majoration si nécessaire
    if (avecMajoration || avecGicleurs) {
        pourcentageFinal = Math.min(100, pourcentageFinal * 2);
    }
    
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction pour le calcul selon 9.10.14.4 ou 9.10.15.4 - MODIFIÉE avec extrapolation
function calculerPourcentage910x(tableau, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    const distances = tableau.distances;
    
    // Vérifier si la distance limitative est supérieure à la plage du tableau
    if (distanceLimitative > distances[distances.length - 1]) {
        return 100; // 100% de baies non protégées autorisées
    }
    
    // Déterminer les surfaces disponibles dans le tableau
    const surfacesDisponibles = Object.keys(tableau.surfaces).filter(s => s !== ">100").map(Number);
    
    // Cas spécial: surface de façade < surface minimale mais DL >= DL minimale non-nulle
    const premiereDLNonNulle = distances.find(d => d > 0);
    if (surfaceFacade < surfacesDisponibles[0] && distanceLimitative >= premiereDLNonNulle) {
        return extrapolerFDRPetiteDLNormale910x(
            tableau, 
            distanceLimitative, 
            surfaceFacade, 
            avecGicleurs, 
            avecMajoration
        );
    }
    
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distances);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distances.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distances.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Trouver les surfaces encadrantes
    let surfaceInferieure, surfaceSuperieure;
    let keyInf, keySup;
    
    if (surfaceFacade <= surfacesDisponibles[0]) {
        // Cas spécial: extrapolation pour petites surfaces (< 30m²)
        if (surfaceFacade < surfacesDisponibles[0]) {
            surfaceInferieure = surfaceFacade;
            surfaceSuperieure = surfacesDisponibles[0];
            keyInf = "extrapolation";
            keySup = surfacesDisponibles[0].toString();
        } else {
            surfaceInferieure = surfaceSuperieure = surfacesDisponibles[0];
            keyInf = keySup = surfacesDisponibles[0].toString();
        }
    } else if (surfaceFacade > surfacesDisponibles[surfacesDisponibles.length - 1]) {
        surfaceInferieure = surfacesDisponibles[surfacesDisponibles.length - 1];
        surfaceSuperieure = Infinity;
        keyInf = surfacesDisponibles[surfacesDisponibles.length - 1].toString();
        keySup = ">100";
    } else {
        for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
            if (surfaceFacade > surfacesDisponibles[i] && surfaceFacade <= surfacesDisponibles[i + 1]) {
                surfaceInferieure = surfacesDisponibles[i];
                surfaceSuperieure = surfacesDisponibles[i + 1];
                keyInf = surfaceInferieure.toString();
                keySup = surfaceSuperieure.toString();
                break;
            }
        }
    }
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        let pourcentageDistance0 = 0; // Toujours 0% quand DL=0
        let pourcentageDistanceMin;
        
        // Vérifier si on a aussi une extrapolation de surface
        if (keyInf === "extrapolation") {
            // Double extrapolation (distance et surface)
            
            // D'abord déterminer le pourcentage pour la surface minimale du tableau à la distance minimale
            const pourcentageDistMinSurfMin = tableau.surfaces[keySup][distanceSuperieureIndex];
            const pourcentageDistMinSurfSupMin = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceSuperieureIndex];
            
            // Extrapolation pour surface plus petite (avec la plus petite distance non-nulle)
            pourcentageDistanceMin = extrapolerPourcentageSurface(
                pourcentageDistMinSurfMin,
                pourcentageDistMinSurfSupMin,
                surfaceSuperieure,
                surfaceFacade
            );
        } else if (keyInf === keySup) {
            // Extrapolation de distance uniquement (surface dans le tableau)
            pourcentageDistanceMin = tableau.surfaces[keyInf][distanceSuperieureIndex];
        } else {
            // Extrapolation de distance et interpolation de surface
            const pourcentageDistMinSurfInf = tableau.surfaces[keyInf][distanceSuperieureIndex];
            const pourcentageDistMinSurfSup = tableau.surfaces[keySup][distanceSuperieureIndex];
            
            // Interpolation entre les surfaces à la distance minimale
            pourcentageDistanceMin = pourcentageDistMinSurfSup + 
                ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
                (pourcentageDistMinSurfInf - pourcentageDistMinSurfSup);
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        let pourcentageFinal = extrapolerPourcentage(
            pourcentageDistance0,
            pourcentageDistanceMin,
            distanceSuperieure,
            distanceExacte
        );
        
        // Appliquer la majoration si nécessaire
        if (avecMajoration || avecGicleurs) {
            pourcentageFinal = Math.min(100, pourcentageFinal * 2);
        }
        
        return Math.max(0, Math.min(100, pourcentageFinal));
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 30m²)
    if (keyInf === "extrapolation") {
        const pourcentageDistInfSurfMin = tableau.surfaces[keySup][distanceInferieureIndex];
        const pourcentageDistInfSurfSupMin = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceInferieureIndex];
        
        // Extrapolation pour surface plus petite
        let pourcentageFinal = extrapolerPourcentageSurface(
            pourcentageDistInfSurfMin,
            pourcentageDistInfSurfSupMin,
            surfaceSuperieure, // Surface min du tableau
            surfaceFacade
        );
        
        // Appliquer la majoration si nécessaire
        if (avecMajoration || avecGicleurs) {
            pourcentageFinal = Math.min(100, pourcentageFinal * 2);
        }
        
        return Math.max(0, Math.min(100, pourcentageFinal));
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    let pourcentageDistanceInferieure;
    
    if (keyInf === keySup) {
        pourcentageDistanceInferieure = tableau.surfaces[keyInf][distanceInferieureIndex];
    } else {
        const pourcentageDistInfSurfInf = tableau.surfaces[keyInf][distanceInferieureIndex];
        const pourcentageDistInfSurfSup = tableau.surfaces[keySup][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageDistInfSurfSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup);
    }

    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        let resultat = pourcentageDistanceInferieure;
        
        // Appliquer la majoration si nécessaire (briques de verre, verre armé ou gicleurs)
        if (avecMajoration || avecGicleurs) {
            resultat = Math.min(100, resultat * 2);
        }
        
        return resultat;
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    let pourcentageDistanceSuperieure;
    
    if (keyInf === keySup) {
        pourcentageDistanceSuperieure = tableau.surfaces[keyInf][distanceSuperieureIndex];
    } else {
        const pourcentageDistSupSurfInf = tableau.surfaces[keyInf][distanceSuperieureIndex];
        const pourcentageDistSupSurfSup = tableau.surfaces[keySup][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageDistSupSurfSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup);
    }
    
    // ÉTAPE 3: Interpolation finale entre les deux résultats d'interpolation précédents
    let pourcentageFinal = pourcentageDistanceInferieure + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    // Appliquer la formule spéciale pour les grandes surfaces si la distance est >= 1.2 m
    if (surfaceFacade > surfacesDisponibles[surfacesDisponibles.length - 1] && distanceLimitative >= 1.2) {
        // Pour le tableau 9.10.14.4-A avec usage "habitation" ou pour 9.10.15.4
        if (!tableau.hasOwnProperty("usages") || tableau.usages === "habitation") {
            pourcentageFinal = Math.pow(distanceLimitative, 2);
        } else { // Pour le tableau 9.10.14.4-A avec usage "commercial"
            pourcentageFinal = 0.5 * Math.pow(distanceLimitative, 2);
        }
    }
    
    // Appliquer la majoration si nécessaire (briques de verre, verre armé ou gicleurs)
    if (avecMajoration || avecGicleurs) {
        pourcentageFinal = Math.min(100, pourcentageFinal * 2);
    }
    
    // Limiter le pourcentage final entre 0 et 100
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction pour calculer le pourcentage de baies non protégées selon CNB
function calculerPourcentageCNB(usage, distanceLimitative, surfaceFacade, length, height, avecGicleurs, glassBrick) {
    // Déterminer le rapport L/H
    const rapportLH = determinerRapportLH(length, height);
    
    // Calculer le pourcentage de base
    let pourcentage = interpolationCNB(
        usage, 
        distanceLimitative, 
        surfaceFacade, 
        rapportLH, 
        avecGicleurs
    );
    
    // Appliquer la majoration pour briques de verre/verre armé si nécessaire
    if (glassBrick) {
        pourcentage = Math.min(100, pourcentage * 2);
    }
    
    return pourcentage;
}

// Version spécifique pour 9.10.14 - MODIFIÉE pour utiliser la fonction calculerPourcentage910x corrigée
function calculerPourcentage91014(usage, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    const tableau = {
        usages: usage,
        surfaces: tableau91014[usage].surfaces,
        distances: tableau91014[usage].distances
    };
    
    return calculerPourcentage910x(tableau, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration);
}

// Version spécifique pour 9.10.15 - MODIFIÉE pour utiliser la fonction calculerPourcentage910x corrigée
function calculerPourcentage91015(distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    return calculerPourcentage910x(tableau91015, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration);
}

function calculateCNB() {
    // Déterminer le système de mesure
    const isImperial = document.getElementById('measurementSystem').value === 'imperial';
    
    // Obtenir les valeurs des champs
    let facadeSurface, length, height, limitingDistance, proposedArea;
    
    if (isImperial) {
        facadeSurface = imperialToMetric(document.getElementById('surface_cnb_imperial').value, "area");
        length = imperialToMetric(document.getElementById('length_cnb_imperial').value);
        height = imperialToMetric(document.getElementById('height_cnb_imperial').value);
        limitingDistance = imperialToMetric(document.getElementById('distance_cnb_imperial').value);
        proposedArea = imperialToMetric(document.getElementById('proposed_area_cnb_imperial').value, "area");
    } else {
        facadeSurface = parseFloat(document.getElementById('surface_cnb').value);
        length = parseFloat(document.getElementById('length_cnb').value);
        height = parseFloat(document.getElementById('height_cnb').value);
        limitingDistance = parseFloat(document.getElementById('distance_cnb').value);
        proposedArea = parseFloat(document.getElementById('proposed_area_cnb').value);
    }
    
    const sprinklersOption = document.getElementById('sprinklers_cnb').value;
    const response = document.getElementById('response_cnb').checked;
    const usage = document.getElementById('usage_cnb').value;
    const constructionType = document.getElementById('construction_type_cnb').value;
    const revetementType = document.getElementById('revetement_type_cnb').value;
    const glassBrick = document.getElementById('glass_brick_cnb').checked;
    const exemptBuilding = document.getElementById('exempt_building_cnb').value;
    const checkSpacing = document.getElementById('check_spacing_cnb').checked;
    
    let horizontalSpacing, verticalSpacing, soffit_distance;
    
    if (isImperial) {
        horizontalSpacing = imperialToMetric(document.getElementById('horizontal_spacing_cnb_imperial').value);
        verticalSpacing = imperialToMetric(document.getElementById('vertical_spacing_cnb_imperial').value);
        soffit_distance = imperialToMetric(document.getElementById('soffit_distance_cnb_imperial').value);
    } else {
        horizontalSpacing = parseFloat(document.getElementById('horizontal_spacing_cnb').value);
        verticalSpacing = parseFloat(document.getElementById('vertical_spacing_cnb').value);
        soffit_distance = parseFloat(document.getElementById('soffit_distance_cnb').value);
    }
    
    const checkSoffit = document.getElementById('check_soffit_cnb').checked;
    const soffit_protected = document.getElementById('soffit_protected_cnb').checked;
    
    // Vérification des entrées
    if (isNaN(facadeSurface) || isNaN(length) || isNaN(height) || isNaN(limitingDistance) || 
        facadeSurface <= 0 || length <= 0 || height <= 0 || limitingDistance < 0) {
        document.getElementById('cnb-result').innerHTML = "Erreur : Veuillez entrer des valeurs numériques valides.";
        return;
    }
    
    // Vérifier si le bâtiment est exempté
    if (exemptBuilding !== "none") {
        let exemptMessage = "";
        if (exemptBuilding === "parking" && limitingDistance >= 3) {
            exemptMessage = `
                <strong>Bâtiment exempté - Garage de stationnement à étages ouverts :</strong><br>
                Selon l'article 3.2.3.10. 1), les façades de rayonnement d'un garage de stationnement dont 
                tous les étages sont des étages ouverts peuvent comporter des baies non protégées sans 
                limitation de surface si la distance limitative est d'au moins 3 m.<br><br>
                <strong>Surface maximale des baies non protégées : 100%</strong>
            `;
        } else if (exemptBuilding === "street_level" && limitingDistance >= 9) {
            exemptMessage = `
                <strong>Bâtiment exempté - Façade donnant sur une rue :</strong><br>
                Selon l'article 3.2.3.10. 2), la partie de la façade de rayonnement donnant sur une rue peut 
                comporter, à l'étage qui se trouve au niveau de la rue, des baies non protégées sans 
                limitation de surface si la distance limitative est d'au moins 9 m.<br><br>
                <strong>Surface maximale des baies non protégées : 100%</strong>
            `;
        } else {
            exemptMessage = `
                <strong>Bâtiment exempté - Conditions non satisfaites :</strong><br>
                Le bâtiment que vous avez sélectionné pourrait être exempté, mais les conditions ne sont pas satisfaites.<br>
                ${exemptBuilding === "parking" ? 
                    "- Pour un garage de stationnement à étages ouverts, la distance limitative doit être d'au moins 3 m." : 
                    "- Pour une façade donnant sur une rue, la distance limitative doit être d'au moins 9 m."}
            `;
        }
        
        if (exemptMessage.includes("100%")) {
            document.getElementById('copy_cnb').style.display = 'inline-block';
            document.getElementById('cnb-result').innerHTML = exemptMessage;
            return;
        }
        // Si non exempté, on continue avec le calcul normal
    }

    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }

    // Utiliser la nouvelle méthode de calcul CNB
    const avecGicleurs = sprinklersOption === "complete";
    let pourcentage = calculerPourcentageCNB(
        usage, 
        limitingDistance, 
        facadeSurface, 
        length, 
        height, 
        avecGicleurs, 
        glassBrick
    );
    
    // Ajouter les précisions concernant 3.1.7.2. 1) et 3.2.3.1. 9) lorsque la distance limitative est < 1,2 m
    let rayonnementInfo = "";
    if (limitingDistance < 1.2) {
        rayonnementInfo = `
            <br><strong>Note concernant le rayonnement thermique :</strong><br>
            Selon l'article 3.1.7.2. 1), la limite d'élévation de température sur la face non exposée d'une construction ne s'applique pas 
            à un mur extérieur ayant une distance limitative de 1,2 m ou plus, pourvu que le rayonnement émis par la face non exposée 
            soit pris en compte pour effectuer une correction conformément au paragraphe 3.2.3.1. 9).<br>
            <br>
            Selon le paragraphe 3.2.3.1. 9), si la température superficielle de la face non exposée d'un mur dépasse les valeurs établies 
            par les essais normalisés de résistance au feu, il faut tenir compte du rayonnement émis par la face non exposée du mur en 
            ajoutant une surface équivalente de baies non protégées.
        `;
    }
    
    // Calculer la surface maximale de baies non protégées
    const maxArea = (pourcentage / 100) * facadeSurface;
    
    // Déterminer les exigences de construction selon 3.2.3.7
    let constructionRequirements = determineConstructionRequirements(pourcentage, usage, constructionType, revetementType);
    
    // Vérification de l'espacement des baies
let spacingResult = "";
if (checkSpacing) {
    const minHorizontalSpacing = 2.0; // En mètres selon 3.2.3.1.(6)
    const minVerticalSpacing = 2.0;   // En mètres selon 3.2.3.1.(6)
    
    if (limitingDistance <= 2.0) {
        if (horizontalSpacing < minHorizontalSpacing || verticalSpacing < minVerticalSpacing) {
            let spacingDisplayH, spacingDisplayV;
            if (isImperial) {
                spacingDisplayH = metricToImperial(horizontalSpacing);
                spacingDisplayV = metricToImperial(verticalSpacing);
            } else {
                spacingDisplayH = horizontalSpacing + " m";
                spacingDisplayV = verticalSpacing + " m";
            }
            
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                ⚠️ <span style="color: red;">NON CONFORME</span> - L'espacement des baies ne respecte pas les exigences minimales.<br>
                Selon l'article 3.2.3.1.(6), l'espacement des baies non protégées desservant une même pièce doit être d'au moins :<br>
                - 2 m horizontalement (valeur saisie: ${spacingDisplayH})<br>
                - 2 m verticalement (valeur saisie: ${spacingDisplayV})
            `;
        } else {
            let spacingDisplayH, spacingDisplayV;
            if (isImperial) {
                spacingDisplayH = metricToImperial(horizontalSpacing);
                spacingDisplayV = metricToImperial(verticalSpacing);
            } else {
                spacingDisplayH = horizontalSpacing + " m";
                spacingDisplayV = verticalSpacing + " m";
            }
            
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                <span style="color: green;">CONFORME</span> - L'espacement des baies respecte les exigences minimales.<br>
                Espacement horizontal: ${spacingDisplayH} (minimum requis: 2 m)<br>
                Espacement vertical: ${spacingDisplayV} (minimum requis: 2 m)
            `;
        }
    } else {
        // Pour les distances > 2.0 m, indiquer que les restrictions ne s'appliquent pas
        spacingResult = `
            <br><strong>Vérification de l'espacement des baies :</strong><br>
            <span style="color: green;">NON APPLICABLE</span> - Les restrictions d'espacement des baies 
            prévues au paragraphe 3.2.3.1.(6) ne s'appliquent que si la distance limitative est d'au plus 2 m.<br>
            Avec une distance limitative de ${isImperial ? metricToImperial(limitingDistance) : limitingDistance.toFixed(2) + " m"} > 2 m, ces restrictions ne s'appliquent pas.
        `;
    }
}
    
    // Vérification de la protection des soffites
    let soffitResult = "";
    if (checkSoffit) {
        let soffitDistanceDisplay;
        if (isImperial) {
            soffitDistanceDisplay = metricToImperial(soffit_distance);
        } else {
            soffitDistanceDisplay = soffit_distance + " m";
        }
        
        if (soffit_distance < 0.45) {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                Selon l'article 3.2.3.6.(2), aucun soffite ne doit faire saillie au-dessus de la façade de rayonnement
                lorsque la distance limitative est inférieure à 0,45 m.<br>
                ${soffit_distance < 0.45 ? 
                    "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffitDistanceDisplay + ") est inférieure à 0,45 m. Aucun soffite n'est autorisé.</span>" : 
                    "La distance du soffite est conforme."}
            `;
        } else if (soffit_distance < 1.2) {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                Selon l'article 3.2.3.6.(3-5), si la distance limitative est entre 0,45 m et 1,2 m, les soffites de toit 
                ne doivent pas faire saillie à moins de 0,45 m de la limite de propriété, ou doivent être protégés.<br>
                ${soffit_distance < 0.45 ? 
                    "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffitDistanceDisplay + ") est inférieure à 0,45 m. Une protection est requise.</span>" : 
                    "La distance du soffite est d'au moins 0,45 m."}
                ${!soffit_protected && soffit_distance < 0.45 ? 
                    "<br>⚠️ <span style=\"color: green;\">Le soffite est protégé selon les exigences.</span>" : ""}
            `;
        } else {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                <span style="color: green;">La distance du soffite (${soffitDistanceDisplay}) est supérieure à 1,2 m. 
                Aucune protection spécifique n'est requise.</span>
            `;
        }
    }

    // Ajouter une mention spéciale si on a fait une extrapolation
    let extrapolationInfo = "";
    if (facadeSurface < 10 || (limitingDistance > 0 && limitingDistance < 1.2)) {
        extrapolationInfo = `
            <br><strong>Remarque sur le calcul :</strong><br>
            ${facadeSurface < 10 ? "La surface de la façade de rayonnement (" + facadeSurface.toFixed(2) + " m²) est inférieure à la valeur minimale du tableau de référence (10 m²).<br>" : ""}
            ${limitingDistance > 0 && limitingDistance < 1.2 ? "La distance limitative (" + limitingDistance.toFixed(2) + " m) est inférieure à la valeur minimale non-nulle du tableau de référence (1,2 m).<br>" : ""}
            Une extrapolation a été effectuée pour obtenir un résultat plus précis.
        `;
    }

   // Afficher les résultats détaillés avec les calculs intermédiaires
   let resultHTML = `
   <strong>Données de calcul :</strong><br>
   ${response ? "Distance limitative ajustée : " + (isImperial ? metricToImperial(limitingDistance) : limitingDistance.toFixed(2) + " m") + "<br>" : ""}
   Rapport L/H ou H/L : ${determinerRapportLH(length, height)}<br>
   Type de construction : ${constructionType}<br>
   Type de revêtement : ${revetementType}<br>
   Protection par gicleurs : ${sprinklersOption === "complete" ? "Complète" : sprinklersOption === "partial" ? "Partielle" : "Aucune"}<br>
   ${glassBrick ? "Majoration pour briques de verre/verre armé appliquée (x2)<br>" : ""}
   
   <br><strong>Résultats :</strong><br>
   Pourcentage maximal de baies non protégées : ${pourcentage.toFixed(2)}%<br>
   Surface maximale de baies non protégées : ${isImperial ? metricToImperial(maxArea, "area") + " (" + maxArea.toFixed(2) + " m²)" : maxArea.toFixed(2) + " m²"}
   ${constructionRequirements}
   ${extrapolationInfo}
   ${rayonnementInfo}
   ${spacingResult}
   ${soffitResult}
`;

    // Ajouter la comparaison avec la surface proposée
    if (!isNaN(proposedArea) && proposedArea > 0) {
        const proposedPercentage = (proposedArea / facadeSurface) * 100;
        let statusClass = "";
        let comparisonResult = "";
        
        let proposedAreaDisplay;
        if (isImperial) {
            proposedAreaDisplay = metricToImperial(proposedArea, "area") + " (" + proposedArea.toFixed(2) + " m²)";
        } else {
            proposedAreaDisplay = proposedArea.toFixed(2) + " m²";
        }
        
        let maxAreaDisplay;
        if (isImperial) {
            maxAreaDisplay = metricToImperial(maxArea, "area") + " (" + maxArea.toFixed(2) + " m²)";
        } else {
            maxAreaDisplay = maxArea.toFixed(2) + " m²";
        }
        
        if (proposedPercentage > pourcentage) {
            statusClass = "color: red; font-weight: bold;";
            comparisonResult = `
                <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                Votre proposition: ${proposedAreaDisplay} (${proposedPercentage.toFixed(2)}% de la façade)<br>
                <span style="${statusClass}">⚠️ La surface proposée dépasse ${maxAreaDisplay} (${pourcentage.toFixed(2)}% de la façade de rayonnement).</span>
            `;
        } else {
            statusClass = "color: green; font-weight: bold;";
            comparisonResult = `
                <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                Votre proposition: ${proposedAreaDisplay} (${proposedPercentage.toFixed(2)}% de la façade)<br>
                <span style="${statusClass}">La surface proposée respecte le maximum autorisé de ${maxAreaDisplay} (${pourcentage.toFixed(2)}%).</span>
            `;
        }
        
        // Ajouter le résultat de comparaison à resultHTML
        resultHTML += comparisonResult;
    }
    
    // Ajouter le message de dégagement de responsabilité
    resultHTML += `
    <br><br><div style="font-style: italic; padding: 10px; border-top: 1px solid #ccc; margin-top: 10px;">
    <strong>Avis de non-responsabilité:</strong> Les résultats générés par cet outil sont fournis à titre indicatif uniquement. 
    L'utilisateur demeure responsable de valider leur conformité auprès d'un professionnel qualifié ou de l'autorité compétente en matière de sécurité incendie.
    </div>
`;           
    document.getElementById('cnb-result').innerHTML = resultHTML;
    document.getElementById('copy_cnb').style.display = 'inline-block';
}

function determineConstructionRequirements(percentage, usage, constructionType, revetementType) {
    // Déterminer le degré de résistance au feu et les exigences de construction selon 3.2.3.7
    let degre = "";
    let constructionExigence = "";
    let revetementExigence = "";
    
    if (percentage <= 10) {
        if (usage === "groupes_A_B3_C_D_F3") {
            degre = "1 h";
        } else { // groupes_E_F1_F2
            degre = "2 h";
        }
        constructionExigence = "Incombustible";
        revetementExigence = "Incombustible";
    } else if (percentage <= 25) {
        if (usage === "groupes_A_B3_C_D_F3") {
            degre = "1 h";
        } else { // groupes_E_F1_F2
            degre = "2 h";
        }
        constructionExigence = "Combustible ou incombustible";
        revetementExigence = "Incombustible";
     } else if (percentage <= 50) {
        if (usage === "groupes_A_B3_C_D_F3") {
            degre = "45 min";
        } else { // groupes_E_F1_F2
            degre = "1 h";
        }
        constructionExigence = "Combustible ou incombustible";
        revetementExigence = "Incombustible";
    } else if (percentage < 100) {
        if (usage === "groupes_A_B3_C_D_F3") {
            degre = "45 min";
        } else { // groupes_E_F1_F2
            degre = "1 h";
        }
        constructionExigence = "Combustible ou incombustible";
        revetementExigence = "Combustible ou incombustible";
    }
    
    // Si la construction actuelle n'est pas conforme, ajouter un avertissement
    let warningMsg = "";
    if ((constructionExigence === "Incombustible" && constructionType === "combustible") ||
        (revetementExigence === "Incombustible" && revetementType === "combustible")) {
        warningMsg = "<br>⚠️ <strong>Attention :</strong> La construction ou le revêtement sélectionné ne respecte pas les exigences minimales du tableau 3.2.3.7.";
    }
    
    return `
        <br><strong>Exigences de construction (tableau 3.2.3.7):</strong><br>
        Pour ${percentage.toFixed(2)}% de baies non protégées:<br>
        - Degré de résistance au feu minimal: ${degre}<br>
        - Type de construction exigé: ${constructionExigence}<br>
        - Type de revêtement exigé: ${revetementExigence}${warningMsg}
    `;
}

function calculate91014() {
    // Déterminer le système de mesure
    const isImperial = document.getElementById('measurementSystem').value === 'imperial';
    
    // Obtenir les valeurs des champs
    let limitingDistance, surface, proposedArea, horizontalSpacing, verticalSpacing, soffit_distance;
    
    if (isImperial) {
        limitingDistance = imperialToMetric(document.getElementById('distance_91014_imperial').value);
        surface = imperialToMetric(document.getElementById('surface_91014_imperial').value, "area");
        proposedArea = imperialToMetric(document.getElementById('proposed_area_91014_imperial').value, "area") || 0;
        horizontalSpacing = imperialToMetric(document.getElementById('horizontal_spacing_91014_imperial').value) || 2;
        verticalSpacing = imperialToMetric(document.getElementById('vertical_spacing_91014_imperial').value) || 2;
        soffit_distance = imperialToMetric(document.getElementById('soffit_distance_91014_imperial').value) || 0.5;
    } else {
        limitingDistance = parseFloat(document.getElementById('distance_91014').value);
        surface = parseFloat(document.getElementById('surface_91014').value);
        proposedArea = parseFloat(document.getElementById('proposed_area_91014').value) || 0;
        horizontalSpacing = parseFloat(document.getElementById('horizontal_spacing_91014').value) || 2;
        verticalSpacing = parseFloat(document.getElementById('vertical_spacing_91014').value) || 2;
        soffit_distance = parseFloat(document.getElementById('soffit_distance_91014').value) || 0.5;
    }
    
    // Récupérer les autres paramètres du formulaire
    const sprinklersOption = document.getElementById('sprinklers_91014').value;
    const glassBrick = document.getElementById('glass_brick_91014').checked;
    const response = document.getElementById('response_91014').checked;
    const usage = document.getElementById('usage_91014').value;
    const buildingType = document.getElementById('building_type_91014').value;
    const exteriorFinish = document.getElementById('exterior_finish_91014').value;
    const checkSpacing = document.getElementById('check_spacing_91014').checked;
    const checkSoffit = document.getElementById('check_soffit_91014').checked;
    const soffit_protected = document.getElementById('soffit_protected_91014').checked;
    const distinction = document.getElementById('distinction_91014').value;
    
    // Vérification des entrées - Ajout de valeurs par défaut si nulles
    if (isNaN(limitingDistance) || limitingDistance < 0) limitingDistance = 0;
    if (isNaN(surface) || surface <= 0) {
        document.getElementById('method91014-result').innerHTML = "Erreur : Veuillez entrer une surface de façade valide.";
        return;
    }

    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }
    
    // Exemption pour les garages ou bâtiments secondaires
    if (buildingType === "garage") {
        // Selon 9.10.14.4.(10-12), les baies vitrées des garages peuvent être exemptées des restrictions
         document.getElementById('method91014-result').innerHTML = `
             <strong>Résultat pour garage ou bâtiment secondaire :</strong><br>
             Selon les paragraphes 9.10.14.4.(10-12) et 9.10.14.5.(4-5), les garages et bâtiments secondaires 
             qui ne desservent qu'un seul logement peuvent bénéficier d'exemptions importantes:<br><br>
             
             - Si le garage dessert un seul logement et est sur la même propriété: 
               <strong>pas de limite de surface pour les baies vitrées</strong><br>
             - Pour la construction de la façade de rayonnement, si la distance limitative est d'au moins 0,6 m:
               <strong>pas d'exigence quant au degré de résistance au feu</strong><br>
             - Si la distance limitative est inférieure à 0,6 m: <strong>un degré de résistance au feu d'au moins 
               45 min est requis</strong><br>
             - <strong>Aucune exigence quant au type de revêtement</strong>, peu importe la distance limitative<br><br>
             
             Pour une analyse plus spécifique, veuillez sélectionner "Bâtiment standard" dans le type de bâtiment.
         `;
         document.getElementById('copy_91014').style.display = 'inline-block';
         return;
     }

    // Si la distance limitative est d'au plus 2 m, activer automatiquement la vérification d'espacement
    if (limitingDistance <= 2.0) {
        // Activer la case à cocher et afficher les options d'espacement
        document.getElementById('check_spacing_91014').checked = true;
        document.getElementById('spacing_options_91014').style.display = 'block';
    }

    // Utiliser la nouvelle méthode de calcul 9.10.14
    const avecGicleurs = sprinklersOption === "complete";
    const pourcentage = calculerPourcentage91014(
        usage, 
        limitingDistance, 
        surface, 
        avecGicleurs, 
        glassBrick
    );
    
    // Calculer la surface maximale
    const maxArea = (pourcentage / 100) * surface;

    // Déterminer les exigences de construction et de protection
    let constructionRequirements = "";

    if (limitingDistance < 1.2) {
        constructionRequirements = `
            <br><strong>Exigences pour distance limitative < 1,2 m (9.10.14.4.2):</strong><br>
            - Les ouvertures doivent être protégées par des dispositifs d'obturation<br>
            - Le verre armé et les briques de verre ne sont pas autorisés<br>
            - ${exteriorFinish === "incombustible" ? 
                "Revêtement incombustible requis pour les façades" : 
                "Revêtement combustible soumis à des restrictions importantes (voir 9.10.14.5)"}
        `;
    }

    // Vérification de l'espacement des baies
let spacingResult = "";
if (checkSpacing) {
    const minHorizontalSpacing = 2.0; // En mètres selon 9.10.14.4.(4)
    const minVerticalSpacing = 2.0;   // En mètres selon 9.10.14.4.(4)
    
    if (limitingDistance <= 2.0) {
        if (horizontalSpacing < minHorizontalSpacing || verticalSpacing < minVerticalSpacing) {
            let spacingDisplayH, spacingDisplayV;
            if (isImperial) {
                spacingDisplayH = metricToImperial(horizontalSpacing);
                spacingDisplayV = metricToImperial(verticalSpacing);
            } else {
                spacingDisplayH = horizontalSpacing + " m";
                spacingDisplayV = verticalSpacing + " m";
            }
            
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                ⚠️ <span style="color: red;">NON CONFORME</span> - L'espacement des baies ne respecte pas les exigences minimales.<br>
                Selon l'article 9.10.14.4.(4), l'espacement des baies non protégées desservant une même pièce doit être d'au moins :<br>
                - 2 m horizontalement (valeur saisie: ${spacingDisplayH})<br>
                - 2 m verticalement (valeur saisie: ${spacingDisplayV})
            `;
        } else {
            let spacingDisplayH, spacingDisplayV;
            if (isImperial) {
                spacingDisplayH = metricToImperial(horizontalSpacing);
                spacingDisplayV = metricToImperial(verticalSpacing);
            } else {
                spacingDisplayH = horizontalSpacing + " m";
                spacingDisplayV = verticalSpacing + " m";
            }
            
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                <span style="color: green;">CONFORME</span> - L'espacement des baies respecte les exigences minimales.<br>
                Espacement horizontal: ${spacingDisplayH} (minimum requis: 2 m)<br>
                Espacement vertical: ${spacingDisplayV} (minimum requis: 2 m)
            `;
        }
    } else {
        // Pour les distances > 2.0 m, indiquer que les restrictions ne s'appliquent pas
        spacingResult = `
            <br><strong>Vérification de l'espacement des baies :</strong><br>
            <span style="color: green;">NON APPLICABLE</span> - Les restrictions d'espacement des baies 
            prévues aux paragraphes 9.10.14.4.(3) et (4) ne s'appliquent que si la distance limitative est d'au plus 2 m.<br>
            Avec une distance limitative de ${isImperial ? metricToImperial(limitingDistance) : limitingDistance.toFixed(2) + " m"} > 2 m, ces restrictions ne s'appliquent pas.
        `;
    }
}
     
     // Vérification de la protection des soffites
     let soffitResult = "";
     if (checkSoffit) {
         let soffitDistanceDisplay;
         if (isImperial) {
             soffitDistanceDisplay = metricToImperial(soffit_distance);
         } else {
             soffitDistanceDisplay = soffit_distance + " m";
         }
         
         if (soffit_distance < 0.45) {
             soffitResult = `
                 <br><strong>Protection des soffites :</strong><br>
                 Selon l'article 9.10.14.5.(9), aucun soffite ne doit faire saillie au-dessus de la façade de rayonnement
                 lorsque la distance limitative est inférieure à 0,45 m.<br>
                 ${soffit_distance < 0.45 ? 
                     "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffitDistanceDisplay + ") est inférieure à 0,45 m. Aucun soffite n'est autorisé.</span>" : 
                     "La distance du soffite est conforme."}
             `;
         } else if (soffit_distance < 1.2) {
             soffitResult = `
                 <br><strong>Protection des soffites :</strong><br>
                 Selon l'article 9.10.14.5.(10-12), si la distance limitative est entre 0,45 m et 1,2 m, les soffites de toit 
                 ne doivent pas faire saillie à moins de 0,45 m de la limite de propriété, ou doivent être protégés.<br>
                 ${soffit_distance < 0.45 ? 
                     "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffitDistanceDisplay + ") est inférieure à 0,45 m. Une protection est requise.</span>" : 
                     "La distance du soffite est d'au moins 0,45 m."}
                 ${!soffit_protected && soffit_distance < 1.2 ? 
                     "<br>⚠️ <span style=\"color: red;\">Le soffite n'est pas protégé selon les exigences.</span>" : 
                     soffit_protected ? "<br><span style=\"color: green;\">Le soffite est protégé selon les exigences.</span>" : ""}
             `;
         } else {
             soffitResult = `
                 <br><strong>Protection des soffites :</strong><br>
                 <span style="color: green;">La distance du soffite (${soffitDistanceDisplay}) est supérieure à 1,2 m. 
                 Aucune protection spécifique n'est requise.</span>
             `;
         }
     }
     
     // Distinction entre baies vitrées et baies non protégées
     let distinctionInfo = "";
     if (distinction === "glazed") {
         distinctionInfo = `
             <br><strong>Type de baies :</strong><br>
             <i>Vous avez spécifié des baies vitrées. En vertu de 9.10.14, les baies vitrées sont une catégorie 
             spécifique de baies non protégées. Les baies vitrées sont soumises aux mêmes restrictions de 
             surface que les baies non protégées, mais peuvent avoir des exigences différentes en matière de 
             construction et de protection.</i>
         `;
     }

     // Ajouter une mention spéciale si on a fait une extrapolation
     let extrapolationInfo = "";
     const surfacesDisponibles = Object.keys(tableau91014[usage].surfaces).filter(s => s !== ">100").map(Number);
     const premiereDLNonNulle = tableau91014[usage].distances.find(d => d > 0);
     
     if (surface < surfacesDisponibles[0] || (limitingDistance > 0 && limitingDistance < premiereDLNonNulle)) {
         extrapolationInfo = `
             <br><strong>Remarque sur le calcul :</strong><br>
             ${surface < surfacesDisponibles[0] ? "La surface de la façade de rayonnement (" + surface.toFixed(2) + " m²) est inférieure à la valeur minimale du tableau de référence (" + surfacesDisponibles[0] + " m²).<br>" : ""}
             ${limitingDistance > 0 && limitingDistance < premiereDLNonNulle ? "La distance limitative (" + limitingDistance.toFixed(2) + " m) est inférieure à la valeur minimale non-nulle du tableau de référence (" + premiereDLNonNulle + " m).<br>" : ""}
             Une extrapolation a été effectuée pour obtenir un résultat plus précis.
         `;
         
         // Ajout de détails sur la méthode d'extrapolation pour le cas spécial
         if (surface < surfacesDisponibles[0] && limitingDistance >= premiereDLNonNulle) {
             extrapolationInfo += `
                 <br><strong>Méthode d'extrapolation utilisée:</strong><br>
                 Pour ce cas de figure particulier (surface < ${surfacesDisponibles[0]} m² et DL ≥ ${premiereDLNonNulle} m),
                 le calcul suit les trois étapes suivantes:
                 <br>1. Interpolation selon la 1ère surface de référence (${surfacesDisponibles[0]} m²)
                 <br>2. Interpolation selon la 2ème surface de référence (${surfacesDisponibles[1]} m²)
                 <br>3. Extrapolation à partir de ces deux valeurs pour la surface réelle (${surface.toFixed(2)} m²)
             `;
         }
     }

     // Afficher les résultats (la partie d'affichage reste la même)
     let resultHTML = `
          <strong>Données de calcul :</strong><br>
          ${response ? "Distance limitative ajustée : " + (isImperial ? metricToImperial(limitingDistance) : limitingDistance.toFixed(2) + " m") + "<br>" : ""}
          Type d'usage : ${usage === "habitation" ? "Habitation, établissement d'affaires et établissement industriel à risques faibles" : "Établissement commercial et établissement industriel à risques moyens"}<br>
          Surface totale de la façade : ${isImperial ? metricToImperial(surface, "area") : surface.toFixed(2) + " m²"}<br>
          Protection par gicleurs : ${sprinklersOption === "complete" ? "Complète" : sprinklersOption === "partial" ? "Partielle" : "Aucune"}<br>
          ${glassBrick ? "Majoration pour briques de verre/verre armé appliquée (x2)<br>" : ""}
          <br><strong>Résultats :</strong><br>
          Pourcentage maximal de baies non protégées : ${pourcentage.toFixed(2)}%<br>
          Surface maximale de baies non protégées : ${isImperial ? metricToImperial(maxArea, "area") + " (" + maxArea.toFixed(2) + " m²)" : maxArea.toFixed(2) + " m²"}
          ${constructionRequirements}
          ${extrapolationInfo}
          ${spacingResult}
          ${soffitResult}
          ${distinctionInfo}
      `;
     
     // Ajouter la comparaison avec la surface proposée si existe
     if (!isNaN(proposedArea) && proposedArea > 0) {
         const proposedPercentage = (proposedArea / surface) * 100;
         let statusClass = "";
         let comparisonResult = "";
         
         let proposedAreaDisplay, maxAreaDisplay;
         if (isImperial) {
             proposedAreaDisplay = metricToImperial(proposedArea, "area") + " (" + proposedArea.toFixed(2) + " m²)";
             maxAreaDisplay = metricToImperial(maxArea, "area") + " (" + maxArea.toFixed(2) + " m²)";
         } else {
             proposedAreaDisplay = proposedArea.toFixed(2) + " m²";
             maxAreaDisplay = maxArea.toFixed(2) + " m²";
         }
         
         if (proposedPercentage > pourcentage) {
             statusClass = "color: red; font-weight: bold;";
             comparisonResult = `
                 <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                 Votre proposition: ${proposedAreaDisplay} (${proposedPercentage.toFixed(2)}% de la façade)<br>
                 <span style="${statusClass}">⚠️ La surface proposée dépasse ${maxAreaDisplay} (${pourcentage.toFixed(2)}% de la façade de rayonnement).</span>
             `;
         } else {
             statusClass = "color: green; font-weight: bold;";
             comparisonResult = `
                 <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                 Votre proposition: ${proposedAreaDisplay} (${proposedPercentage.toFixed(2)}% de la façade)<br>
                 <span style="${statusClass}">La surface proposée respecte le maximum autorisé de ${maxAreaDisplay} (${pourcentage.toFixed(2)}%).</span>
             `;
         }
         
         // Ajouter le résultat de comparaison à resultHTML
         resultHTML += comparisonResult;
     }
     
     // Ajouter le message de dégagement de responsabilité
     resultHTML += `
     <br><br><div style="font-style: italic; padding: 10px; border-top: 1px solid #ccc; margin-top: 10px;">
     <strong>Avis de non-responsabilité:</strong> Les résultats générés par cet outil sont fournis à titre indicatif uniquement. 
     L'utilisateur demeure responsable de valider leur conformité auprès d'un professionnel qualifié ou de l'autorité compétente en matière de sécurité incendie.
     </div>
`;           
     document.getElementById('method91014-result').innerHTML = resultHTML;
     document.getElementById('copy_91014').style.display = 'inline-block';
}

function calculate91015() {
    // Déterminer le système de mesure
    const isImperial = document.getElementById('measurementSystem').value === 'imperial';
    
    // Obtenir les valeurs des champs
    let limitingDistance, surface, proposedArea, horizontalSpacing, verticalSpacing, soffit_distance;
    
    if (isImperial) {
        limitingDistance = imperialToMetric(document.getElementById('distance_91015_imperial').value);
        surface = imperialToMetric(document.getElementById('surface_91015_imperial').value, "area");
        proposedArea = imperialToMetric(document.getElementById('proposed_area_91015_imperial').value, "area");
        horizontalSpacing = imperialToMetric(document.getElementById('horizontal_spacing_91015_imperial').value);
        verticalSpacing = imperialToMetric(document.getElementById('vertical_spacing_91015_imperial').value);
        soffit_distance = imperialToMetric(document.getElementById('soffit_distance_91015_imperial').value);
    } else {
        limitingDistance = parseFloat(document.getElementById('distance_91015').value);
        surface = parseFloat(document.getElementById('surface_91015').value);
        proposedArea = parseFloat(document.getElementById('proposed_area_91015').value);
        horizontalSpacing = parseFloat(document.getElementById('horizontal_spacing_91015').value);
        verticalSpacing = parseFloat(document.getElementById('vertical_spacing_91015').value);
        soffit_distance = parseFloat(document.getElementById('soffit_distance_91015').value);
    }
    
    const sprinklersOption = document.getElementById('sprinklers_91015').value;
    const glassBrick = document.getElementById('glass_brick_91015').checked;
    const response = document.getElementById('response_91015').checked;
    const housingType = document.getElementById('housing_type_91015').value;
    const revetingType = document.getElementById('reveting_type_91015').value;
    const checkSpacing = document.getElementById('check_spacing_91015').checked;
    const checkSoffit = document.getElementById('check_soffit_91015').checked;
    const soffit_protected = document.getElementById('soffit_protected_91015').checked;
    const distinction = document.getElementById('distinction_91015').value;

    // Vérification des entrées
    if (isNaN(limitingDistance) || isNaN(surface) || limitingDistance < 0 || surface <= 0) {
        document.getElementById('method91015-result').innerHTML = "Erreur : Veuillez entrer des valeurs numériques valides.";
        return;
    }

    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }

    // Utiliser la nouvelle méthode de calcul 9.10.15
    const avecGicleurs = sprinklersOption === "complete";
    const pourcentage = calculerPourcentage91015(
        limitingDistance, 
        surface, 
        avecGicleurs, 
        glassBrick
    );
    
    // Calculer la surface maximale
    const maxArea = (pourcentage / 100) * surface;
    
    // Déterminer les exigences de construction
    let constructionRequirements = "";
    if (limitingDistance < 0.6) {
        constructionRequirements = `
            <br><strong>Exigences de construction (selon 9.10.15.5):</strong><br>
            - Degré de résistance au feu d'au moins 45 min pour la façade de rayonnement<br>
            - Revêtement extérieur ${revetingType === "incombustible" ? "incombustible" : "combustible avec contraintes"}<br>
            ${revetingType === "combustible" ? 
            `- Le revêtement combustible doit être installé selon l'article 9.10.15.5, paragraphe 2):<br>
               &nbsp;&nbsp;• Posé sur revêtement en plaques de plâtre d'au moins 12,7 mm ou maçonnerie<br>
               &nbsp;&nbsp;• Doit avoir un indice de propagation de la flamme d'au plus 25<br>
               &nbsp;&nbsp;• Si c'est un revêtement conforme à 9.27.12, son épaisseur ne doit pas dépasser 2 mm<br>
               &nbsp;&nbsp;• Peut aussi être conforme à l'alinéa 3.1.5.5.1)b)`
             : ""}
        `;
    } else if (limitingDistance < 1.2) {
        constructionRequirements = `
            <br><strong>Exigences de construction (selon 9.10.15.5):</strong><br>
            - Degré de résistance au feu d'au moins 45 min pour la façade de rayonnement<br>
            ${revetingType === "combustible" ? 
            `- Revêtement combustible soumis aux exigences du paragraphe 3) de l'article 9.10.15.5:<br>
               &nbsp;&nbsp;• Si conforme à 9.27.6, 9.27.7, 9.27.8, 9.27.9 ou 9.27.10:<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Posé sur revêtement en plaques de plâtre d'au moins 12,7 mm ou maçonnerie<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Doit avoir un indice de propagation de la flamme d'au plus 25 après conditionnement<br>
               &nbsp;&nbsp;• Si conforme à 9.27.12:<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Posé sur revêtement en plaques de plâtre d'au moins 12,7 mm ou maçonnerie<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Doit avoir un indice de propagation de la flamme d'au plus 25<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Ne doit pas dépasser 2 mm d'épaisseur<br>
               &nbsp;&nbsp;• Peut aussi être conforme à l'alinéa 3.1.5.5.1)b)`
             : "- Revêtement incombustible selon la section 9.20, la sous-section 9.27.11 ou la section 9.28"}
        `;
    } else {
        constructionRequirements = `
            <br><strong>Exigences de construction (selon 9.10.15.5):</strong><br>
            - Pour distance limitative ≥ 1,2 m: les restrictions sont moins sévères<br>
            - Les exigences minimales pour les soffites s'appliquent quand ils font saillie à moins de 1,2 m de la limite de propriété<br>
            - Pour les poteaux en gros bois d'œuvre: pas de conformité nécessaire si distance ≥ 3 m
        `;
    }
    
    // Vérification de l'espacement des baies
let spacingResult = "";
if (checkSpacing) {
    const minHorizontalSpacing = 2.0; // En mètres selon 9.10.15.4.(4)
    const minVerticalSpacing = 2.0;   // En mètres selon 9.10.15.4.(4)
    
    if (limitingDistance <= 2.0) {
        if (horizontalSpacing < minHorizontalSpacing || verticalSpacing < minVerticalSpacing) {
            let spacingDisplayH, spacingDisplayV;
            if (isImperial) {
                spacingDisplayH = metricToImperial(horizontalSpacing);
                spacingDisplayV = metricToImperial(verticalSpacing);
            } else {
                spacingDisplayH = horizontalSpacing + " m";
                spacingDisplayV = verticalSpacing + " m";
            }
            
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                ⚠️ <span style="color: red;">NON CONFORME</span> - L'espacement des baies ne respecte pas les exigences minimales.<br>
                Selon l'article 9.10.15.4.(4), l'espacement des baies vitrées desservant une même pièce doit être d'au moins :<br>
                - 2 m horizontalement (valeur saisie: ${spacingDisplayH})<br>
                - 2 m verticalement (valeur saisie: ${spacingDisplayV})
            `;
        } else {
            let spacingDisplayH, spacingDisplayV;
            if (isImperial) {
                spacingDisplayH = metricToImperial(horizontalSpacing);
                spacingDisplayV = metricToImperial(verticalSpacing);
            } else {
                spacingDisplayH = horizontalSpacing + " m";
                spacingDisplayV = verticalSpacing + " m";
            }
            
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                <span style="color: green;">CONFORME</span> - L'espacement des baies respecte les exigences minimales.<br>
                Espacement horizontal: ${spacingDisplayH} (minimum requis: 2 m)<br>
                Espacement vertical: ${spacingDisplayV} (minimum requis: 2 m)
            `;
        }
    } else {
        // Pour les distances > 2.0 m, indiquer que les restrictions ne s'appliquent pas
        spacingResult = `
            <br><strong>Vérification de l'espacement des baies :</strong><br>
            <span style="color: green;">NON APPLICABLE</span> - Les restrictions d'espacement des baies 
            prévues aux paragraphes 9.10.15.4.(3) et (4) ne s'appliquent que si la distance limitative est d'au plus 2 m.<br>
            Avec une distance limitative de ${isImperial ? metricToImperial(limitingDistance) : limitingDistance.toFixed(2) + " m"} > 2 m, ces restrictions ne s'appliquent pas.
        `;
    }
}
   
   // Vérification de la protection des soffites
   let soffitResult = "";
   if (checkSoffit) {
       let soffitDistanceDisplay;
       if (isImperial) {
           soffitDistanceDisplay = metricToImperial(soffit_distance);
       } else {
           soffitDistanceDisplay = soffit_distance + " m";
       }
       
       if (soffit_distance < 0.45) {
           soffitResult = `
               <br><strong>Protection des soffites :</strong><br>
               Selon l'article 9.10.15.5.(8), aucun soffite ne doit faire saillie au-dessus de la façade de rayonnement
               lorsque la distance limitative est inférieure à 0,45 m.<br>
               ${soffit_distance < 0.45 ? 
                   "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffitDistanceDisplay + ") est inférieure à 0,45 m. Aucun soffite n'est autorisé.</span>" : 
                   "La distance du soffite est conforme."}
           `;
       } else if (soffit_distance < 1.2) {
           soffitResult = `
               <br><strong>Protection des soffites :</strong><br>
               Selon l'article 9.10.15.5.(9-11), si la distance limitative est entre 0,45 m et 1,2 m, les soffites de toit 
               ne doivent pas faire saillie à moins de 0,45 m de la limite de propriété, ou doivent être protégés.<br>
               ${soffit_distance < 0.45 ? 
                   "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffitDistanceDisplay + ") est inférieure à 0,45 m. Une protection est requise.</span>" : 
                   "La distance du soffite est d'au moins 0,45 m."}
               ${!soffit_protected && soffit_distance < 1.2 ? 
                   "<br>⚠️ <span style=\"color: red;\">Le soffite n'est pas protégé selon les exigences.</span>" : 
                   soffit_protected ? "<br><span style=\"color: green;\">Le soffite est protégé selon les exigences.</span>" : ""}
           `;
       } else {
           soffitResult = `
               <br><strong>Protection des soffites :</strong><br>
               <span style="color: green;">La distance du soffite (${soffitDistanceDisplay}) est supérieure à 1,2 m. 
               Aucune protection spécifique n'est requise.</span>
           `;
       }
   }
   
   // Ajouter des informations spécifiques au type d'habitation
   let housingInfo = "";
   if (housingType === "accessoire") {
       housingInfo = `
           <br><strong>Remarque pour logement accessoire:</strong><br>
           - Les maisons comportant un logement accessoire peuvent avoir des exigences supplémentaires.<br>
           - Vérifier également les exigences de l'article 9.10.15.5 pour les revêtements.<br>
       `;
   }
   
   // Distinction entre baies vitrées et baies non protégées
   let distinctionInfo = "";
   if (distinction === "glazed") {
       distinctionInfo = `
           <br><strong>Type de baies :</strong><br>
           <i>Vous avez spécifié des baies vitrées. La sous-section 9.10.15 fait spécifiquement référence 
           aux baies vitrées, qui sont une catégorie de baies non protégées. La distinction est importante 
           car certaines exigences peuvent varier.</i>
       `;
   }

   // Ajouter une mention spéciale si on a fait une extrapolation
   let extrapolationInfo = "";
   const surfacesDisponibles = Object.keys(tableau91015.surfaces).filter(s => s !== ">100").map(Number);
   const premiereDLNonNulle = tableau91015.distances.find(d => d > 0);
   
   if (surface < surfacesDisponibles[0] || (limitingDistance > 0 && limitingDistance < premiereDLNonNulle)) {
       extrapolationInfo = `
           <br><strong>Remarque sur le calcul :</strong><br>
           ${surface < surfacesDisponibles[0] ? "La surface de la façade de rayonnement (" + surface.toFixed(2) + " m²) est inférieure à la valeur minimale du tableau de référence (" + surfacesDisponibles[0] + " m²).<br>" : ""}
           ${limitingDistance > 0 && limitingDistance < premiereDLNonNulle ? "La distance limitative (" + limitingDistance.toFixed(2) + " m) est inférieure à la valeur minimale non-nulle du tableau de référence (" + premiereDLNonNulle + " m).<br>" : ""}
           Une extrapolation a été effectuée pour obtenir un résultat plus précis.
       `;
       
       // Ajout de détails sur la méthode d'extrapolation pour le cas spécial
       if (surface < surfacesDisponibles[0] && limitingDistance >= premiereDLNonNulle) {
           extrapolationInfo += `
               <br><strong>Méthode d'extrapolation utilisée:</strong><br>
               Pour ce cas de figure particulier (surface < ${surfacesDisponibles[0]} m² et DL ≥ ${premiereDLNonNulle} m),
               le calcul suit les trois étapes suivantes:
               <br>1. Interpolation selon la 1ère surface de référence (${surfacesDisponibles[0]} m²)
               <br>2. Interpolation selon la 2ème surface de référence (${surfacesDisponibles[1]} m²)
               <br>3. Extrapolation à partir de ces deux valeurs pour la surface réelle (${surface.toFixed(2)} m²)
           `;
       }
   }

   // Afficher les résultats (la partie d'affichage reste la même)
   let resultHTML = `
       <strong>Données de calcul :</strong><br>
       ${response ? "Distance limitative ajustée : " + (isImperial ? metricToImperial(limitingDistance) : limitingDistance.toFixed(2) + " m") + "<br>" : ""}
       Surface totale de la façade : ${isImperial ? metricToImperial(surface, "area") : surface.toFixed(2) + " m²"}<br>
       Type d'habitation : ${housingType === "standard" ? "Habitation standard" : "Maison comportant un logement accessoire"}<br>
       Type de revêtement : ${revetingType === "combustible" ? "Combustible" : "Incombustible"}<br>
       Protection par gicleurs : ${sprinklersOption === "complete" ? "Complète" : sprinklersOption === "partial" ? "Partielle" : "Aucune"}<br>
       ${glassBrick ? "Majoration pour briques de verre/verre armé appliquée (x2)<br>" : ""}
       <br><strong>Résultats :</strong><br>
       Pourcentage maximal de baies non protégées : ${pourcentage.toFixed(2)}%<br>
       Surface maximale de baies non protégées : ${isImperial ? metricToImperial(maxArea, "area") + " (" + maxArea.toFixed(2) + " m²)" : maxArea.toFixed(2) + " m²"}
       ${constructionRequirements}
       ${extrapolationInfo}
       ${spacingResult}
       ${soffitResult}
       ${housingInfo}
       ${distinctionInfo}
   `;

   // Ajouter la comparaison avec la surface proposée si existe
   if (!isNaN(proposedArea) && proposedArea > 0) {
       const proposedPercentage = (proposedArea / surface) * 100;
       let statusClass = "";
       let comparisonResult = "";
       
       let proposedAreaDisplay, maxAreaDisplay;
       if (isImperial) {
           proposedAreaDisplay = metricToImperial(proposedArea, "area") + " (" + proposedArea.toFixed(2) + " m²)";
           maxAreaDisplay = metricToImperial(maxArea, "area") + " (" + maxArea.toFixed(2) + " m²)";
       } else {
           proposedAreaDisplay = proposedArea.toFixed(2) + " m²";
           maxAreaDisplay = maxArea.toFixed(2) + " m²";
       }
       
       if (proposedPercentage > pourcentage) {
           statusClass = "color: red; font-weight: bold;";
           comparisonResult = `
               <br><br><strong>Comparaison avec la surface proposée:</strong><br>
               Votre proposition: ${proposedAreaDisplay} (${proposedPercentage.toFixed(2)}% de la façade)<br>
               <span style="${statusClass}">⚠️ La surface proposée dépasse ${maxAreaDisplay} (${pourcentage.toFixed(2)}% de la façade de rayonnement).</span>
           `;
       } else {
           statusClass = "color: green; font-weight: bold;";
           comparisonResult = `
               <br><br><strong>Comparaison avec la surface proposée:</strong><br>
               Votre proposition: ${proposedAreaDisplay} (${proposedPercentage.toFixed(2)}% de la façade)<br>
               <span style="${statusClass}">La surface proposée respecte le maximum autorisé de ${maxAreaDisplay} (${pourcentage.toFixed(2)}%).</span>
           `;
       }
       
       // Ajouter le résultat de comparaison à resultHTML
       resultHTML += comparisonResult;
   }
   
   // Ajouter le message de dégagement de responsabilité
   resultHTML += `
   <br><br><div style="font-style: italic; padding: 10px; border-top: 1px solid #ccc; margin-top: 10px;">
   <strong>Avis de non-responsabilité:</strong> Les résultats générés par cet outil sont fournis à titre indicatif uniquement. 
   L'utilisateur demeure responsable de valider leur conformité auprès d'un professionnel qualifié ou de l'autorité compétente en matière de sécurité incendie.
   </div>
`;
   
   document.getElementById('method91015-result').innerHTML = resultHTML;
   document.getElementById('copy_91015').style.display = 'inline-block';
}

function openTab(event, tabName) {
    var tabcontent = document.getElementsByClassName("tab-content");
    for (var i = 0; i < tabcontent.length; i++) {
        tabcontent[i].classList.remove("active");
    }
    var tablinks = document.getElementsByClassName("tab-link");
    for (var i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove("active");
    }
    document.getElementById(tabName).classList.add("active");
    event.currentTarget.classList.add("active");
}

// Fonction pour formater les calculs d'interpolation pour le CNB selon le format demandé
function formatCNBCalculationSteps() {
    // Déterminer le système de mesure et récupérer les valeurs
    const isImperial = document.getElementById('measurementSystem').value === 'imperial';
    
    let facadeSurface, length, height, limitingDistance, rapportLH;
    
    if (isImperial) {
        facadeSurface = imperialToMetric(document.getElementById('surface_cnb_imperial').value, "area");
        length = imperialToMetric(document.getElementById('length_cnb_imperial').value);
        height = imperialToMetric(document.getElementById('height_cnb_imperial').value);
        limitingDistance = imperialToMetric(document.getElementById('distance_cnb_imperial').value);
    } else {
        facadeSurface = parseFloat(document.getElementById('surface_cnb').value);
        length = parseFloat(document.getElementById('length_cnb').value);
        height = parseFloat(document.getElementById('height_cnb').value);
        limitingDistance = parseFloat(document.getElementById('distance_cnb').value);
    }
    
    const sprinklersOption = document.getElementById('sprinklers_cnb').value;
    const response = document.getElementById('response_cnb').checked;
    const usage = document.getElementById('usage_cnb').value;
    const glassBrick = document.getElementById('glass_brick_cnb').checked;
    
    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }

    rapportLH = determinerRapportLH(length, height);
    
    // Préparer le texte formaté pour le presse-papier selon les exemples fournis
    let output = "";
    
    // Utiliser le tableau approprié selon la protection par gicleurs
    if (sprinklersOption === "complete") {
        // Bâtiment entièrement protégé par gicleurs
        if (usage === "groupes_A_B3_C_D_F3") {
            output = "Tableau 3.2.3.1.-D:\n";
        } else { // groupes_E_F1_F2
            output = "Tableau 3.2.3.1.-E:\n";
        }
    } else {
        // Bâtiment sans protection complète par gicleurs
        if (usage === "groupes_A_B3_C_D_F3") {
            output = "Tableau 3.2.3.1.-B:\n";
        } else { // groupes_E_F1_F2
            output = "Tableau 3.2.3.1.-C:\n";
        }
    }
    
    output += `DL: ${limitingDistance.toFixed(2)}m\n`;
    output += `Surface de la FDR: ${facadeSurface.toFixed(2)}m²\n`;
    
    // Ajouter les proportions L/H seulement pour les tableaux sans gicleurs
    if (sprinklersOption !== "complete") {
        output += `Proportion L/H : Largeur : ${length.toFixed(2)}m ; Hauteur : ${height.toFixed(2)}m\n`;
        output += `Le rapport L/H est situé ${rapportLH}\n`;
    }
    
    // Déterminer les tableaux à utiliser
    const avecGicleurs = sprinklersOption === "complete";
    let tableauUtilise, distancesUtilisees, surfacesUtilisees;
    
    if (avecGicleurs) {
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauAvecGicleursGroupesABCDF3;
            distancesUtilisees = limitingDistancesWithSprinklersABCDF3;
            surfacesUtilisees = facadeSurfacesWithSprinklersABCDF3;
        } else { // groupes_E_F1_F2
            tableauUtilise = tableauAvecGicleursGroupesEF1F2;
            distancesUtilisees = limitingDistancesWithSprinklersEF1F2;
            surfacesUtilisees = facadeSurfacesWithSprinklersEF1F2;
        }
    } else {
        distancesUtilisees = limitingDistancesNoSprinklers;
        surfacesUtilisees = facadeSurfaces;
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauGroupesAB3CDF3;
        } else { // groupes_E_F1_F2
            tableauUtilise = tableauGroupesEF1F2;
        }
    }
    
    // Trouver les bornes d'encadrement pour la distance limitative
    const distancesEncadrantes = trouverValeurEncadrantes(limitingDistance, distancesUtilisees);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distancesUtilisees.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distancesUtilisees.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Trouver les surfaces encadrantes
    const surfaceFacadeMin = Math.min(facadeSurface, surfacesUtilisees[0]); // Pour l'extrapolation
    const surfacesEncadrantes = trouverValeurEncadrantes(facadeSurface, surfacesUtilisees);
    const surfaceInferieure = surfacesEncadrantes.inferieure;
    const surfaceSuperieure = surfacesEncadrantes.superieure;
    
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    const extrapolationSurface = facadeSurface < surfacesUtilisees[0];
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        output += "\nCas spécial: Extrapolation pour distance limitative entre 0 et " + distanceSuperieure + "m\n\n";
        
        output += "Étape 1: Calcul à DL = 0m\n";
        output += "À DL = 0m, le pourcentage de baies non protégées est toujours de 0%\n\n";
        
        output += "Étape 2: Calcul à DL = " + distanceSuperieure + "m\n";
        
        if (extrapolationSurface) {
            // Double extrapolation (distance et surface)
            output += "Cas de double extrapolation (distance et surface)\n";
            
            // Pour la surface minimale du tableau à la distance minimale non-nulle
            if (!avecGicleurs) {
                const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceSuperieureIndex];
                const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceSuperieureIndex];
                
                output += `À DL de ${distanceSuperieure}m et surface min. du tableau de ${surfacesUtilisees[0]}m²: ${pourcentageSurfMin}%\n`;
                output += `À DL de ${distanceSuperieure}m et surface suivante du tableau de ${surfacesUtilisees[1]}m²: ${pourcentageSurfSupMin}%\n`;
                
                // Calcul d'extrapolation pour surface plus petite
                const tendance = pourcentageSurfMin - pourcentageSurfSupMin;
                const ratio = surfacesUtilisees[0] / facadeSurface;
                const facteur = Math.sqrt(ratio);
                const extrapolation = pourcentageSurfMin + tendance * (facteur - 1);
                
                output += `Extrapolation pour surface de ${facadeSurface.toFixed(2)}m²: ${pourcentageSurfMin} + (${tendance.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${extrapolation.toFixed(2)}%\n\n`;
                
                output += "Étape 3: Extrapolation finale pour DL = " + limitingDistance.toFixed(2) + "m\n";
                const pourcentageFinal = extrapolerPourcentage(0, extrapolation, distanceSuperieure, limitingDistance);
                output += `0 + (${extrapolation.toFixed(2)} - 0) × (${limitingDistance.toFixed(2)} / ${distanceSuperieure}) = ${pourcentageFinal.toFixed(2)}%\n`;
            } else {
                // Version avec gicleurs
                const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][distanceSuperieureIndex];
                const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][distanceSuperieureIndex];
                
                output += `À DL de ${distanceSuperieure}m et surface min. du tableau de ${surfacesUtilisees[0]}m²: ${pourcentageSurfMin}%\n`;
                output += `À DL de ${distanceSuperieure}m et surface suivante du tableau de ${surfacesUtilisees[1]}m²: ${pourcentageSurfSupMin}%\n`;
                
                // Calcul d'extrapolation pour surface plus petite
                const tendance = pourcentageSurfMin - pourcentageSurfSupMin;
                const ratio = surfacesUtilisees[0] / facadeSurface;
                const facteur = Math.sqrt(ratio);
                const extrapolation = pourcentageSurfMin + tendance * (facteur - 1);
                
                output += `Extrapolation pour surface de ${facadeSurface.toFixed(2)}m²: ${pourcentageSurfMin} + (${tendance.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${extrapolation.toFixed(2)}%\n\n`;
                
                output += "Étape 3: Extrapolation finale pour DL = " + limitingDistance.toFixed(2) + "m\n";
                const pourcentageFinal = extrapolerPourcentage(0, extrapolation, distanceSuperieure, limitingDistance);
                output += `0 + (${extrapolation.toFixed(2)} - 0) × (${limitingDistance.toFixed(2)} / ${distanceSuperieure}) = ${pourcentageFinal.toFixed(2)}%\n`;
            }
        } else {
            // Extrapolation simple pour la distance uniquement
            if (!avecGicleurs) {
                const pourcentageDistMin = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
                output += `À DL de ${distanceSuperieure}m et surface de ${surfaceInferieure}m²: ${pourcentageDistMin}%\n\n`;
                
                output += "Étape 3: Extrapolation finale pour DL = " + limitingDistance.toFixed(2) + "m\n";
                const pourcentageFinal = extrapolerPourcentage(0, pourcentageDistMin, distanceSuperieure, limitingDistance);
                output += `0 + (${pourcentageDistMin} - 0) × (${limitingDistance.toFixed(2)} / ${distanceSuperieure}) = ${pourcentageFinal.toFixed(2)}%\n`;
            } else {
                const pourcentageDistMin = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
                output += `À DL de ${distanceSuperieure}m et surface de ${surfaceInferieure}m²: ${pourcentageDistMin}%\n\n`;
                
                output += "Étape 3: Extrapolation finale pour DL = " + limitingDistance.toFixed(2) + "m\n";
                const pourcentageFinal = extrapolerPourcentage(0, pourcentageDistMin, distanceSuperieure, limitingDistance);
                output += `0 + (${pourcentageDistMin} - 0) × (${limitingDistance.toFixed(2)} / ${distanceSuperieure}) = ${pourcentageFinal.toFixed(2)}%\n`;
            }
        }
        
        return output;
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    if (extrapolationSurface) {
        output += "\nCas spécial: Extrapolation pour surface inférieure à " + surfacesUtilisees[0] + "m²\n\n";
        
        if (!avecGicleurs) {
            const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceInferieureIndex];
            const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceInferieureIndex];
            
            output += `Étape 1: Calcul à DL = ${distanceInferieure}m\n`;
            output += `À DL de ${distanceInferieure}m et surface min. du tableau de ${surfacesUtilisees[0]}m²: ${pourcentageSurfMin}%\n`;
            output += `À DL de ${distanceInferieure}m et surface suivante du tableau de ${surfacesUtilisees[1]}m²: ${pourcentageSurfSupMin}%\n`;
            
            // Calcul d'extrapolation pour surface plus petite
            const tendance = pourcentageSurfMin - pourcentageSurfSupMin;
            const ratio = surfacesUtilisees[0] / facadeSurface;
            const facteur = Math.sqrt(ratio);
            const etape1 = pourcentageSurfMin + tendance * (facteur - 1);
            
            output += `Extrapolation pour surface de ${facadeSurface.toFixed(2)}m²: ${pourcentageSurfMin} + (${tendance.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${etape1.toFixed(2)}%\n\n`;
            
            // Étape 2 si nécessaire (si distance supérieure différente)
            if (distanceInferieure !== distanceSuperieure) {
                const pourcentageSurfMinSup = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceSuperieureIndex];
                const pourcentageSurfSupMinSup = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceSuperieureIndex];
                
                output += `Étape 2: Calcul à DL = ${distanceSuperieure}m\n`;
                output += `À DL de ${distanceSuperieure}m et surface min. du tableau de ${surfacesUtilisees[0]}m²: ${pourcentageSurfMinSup}%\n`;
                output += `À DL de ${distanceSuperieure}m et surface suivante du tableau de ${surfacesUtilisees[1]}m²: ${pourcentageSurfSupMinSup}%\n`;
                
                const tendanceSup = pourcentageSurfMinSup - pourcentageSurfSupMinSup;
                const etape2 = pourcentageSurfMinSup + tendanceSup * (facteur - 1);
                
                output += `Extrapolation pour surface de ${facadeSurface.toFixed(2)}m²: ${pourcentageSurfMinSup} + (${tendanceSup.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${etape2.toFixed(2)}%\n\n`;
                
                output += `Étape 3: Interpolation finale pour DL = ${limitingDistance.toFixed(2)}m\n`;
                const pourcentageFinal = etape1 + 
                    ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                    (etape2 - etape1);
                
                output += `${etape1.toFixed(2)} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${etape2.toFixed(2)} - ${etape1.toFixed(2)}) = ${pourcentageFinal.toFixed(2)}%\n`;
            } else {
                // Une seule distance, l'extrapolation est déjà faite
                output += `Étape 3: Le résultat final est ${etape1.toFixed(2)}% (pas d'interpolation de distance nécessaire)\n`;
            }
        } else {
            // Version avec gicleurs
            const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][distanceInferieureIndex];
            const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][distanceInferieureIndex];
            
            output += `Étape 1: Calcul à DL = ${distanceInferieure}m\n`;
            output += `À DL de ${distanceInferieure}m et surface min. du tableau de ${surfacesUtilisees[0]}m²: ${pourcentageSurfMin}%\n`;
            output += `À DL de ${distanceInferieure}m et surface suivante du tableau de ${surfacesUtilisees[1]}m²: ${pourcentageSurfSupMin}%\n`;
            
            // Calcul d'extrapolation pour surface plus petite
            const tendance = pourcentageSurfMin - pourcentageSurfSupMin;
            const ratio = surfacesUtilisees[0] / facadeSurface;
            const facteur = Math.sqrt(ratio);
            const etape1 = pourcentageSurfMin + tendance * (facteur - 1);
            
            output += `Extrapolation pour surface de ${facadeSurface.toFixed(2)}m²: ${pourcentageSurfMin} + (${tendance.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${etape1.toFixed(2)}%\n\n`;
            
            // Étape 2 si nécessaire (si distance supérieure différente)
            if (distanceInferieure !== distanceSuperieure) {
                const pourcentageSurfMinSup = tableauUtilise[surfacesUtilisees[0]][distanceSuperieureIndex];
                const pourcentageSurfSupMinSup = tableauUtilise[surfacesUtilisees[1]][distanceSuperieureIndex];
                
                output += `Étape 2: Calcul à DL = ${distanceSuperieure}m\n`;
                output += `À DL de ${distanceSuperieure}m et surface min. du tableau de ${surfacesUtilisees[0]}m²: ${pourcentageSurfMinSup}%\n`;
                output += `À DL de ${distanceSuperieure}m et surface suivante du tableau de ${surfacesUtilisees[1]}m²: ${pourcentageSurfSupMinSup}%\n`;
                
                const tendanceSup = pourcentageSurfMinSup - pourcentageSurfSupMinSup;
                const etape2 = pourcentageSurfMinSup + tendanceSup * (facteur - 1);
                
                output += `Extrapolation pour surface de ${facadeSurface.toFixed(2)}m²: ${pourcentageSurfMinSup} + (${tendanceSup.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${etape2.toFixed(2)}%\n\n`;
                
                output += `Étape 3: Interpolation finale pour DL = ${limitingDistance.toFixed(2)}m\n`;
                const pourcentageFinal = etape1 + 
                    ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                    (etape2 - etape1);
                
                output += `${etape1.toFixed(2)} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${etape2.toFixed(2)} - ${etape1.toFixed(2)}) = ${pourcentageFinal.toFixed(2)}%\n`;
            } else {
                // Une seule distance, l'extrapolation est déjà faite
                output += `Étape 3: Le résultat final est ${etape1.toFixed(2)}% (pas d'interpolation de distance nécessaire)\n`;
            }
        }
        
        return output;
    }
    
    // Cas spécial pour FDR petite et DL >= DL minimale non-nulle
    const premiereDLNonNulle = distancesUtilisees.find(d => d > 0);
    if (facadeSurface < surfacesUtilisees[0] && limitingDistance >= premiereDLNonNulle) {
        output += "\nCas spécial: Extrapolation pour petite surface avec DL normale\n\n";
        
        // Étape 1: Calcul pour la 1ère surface disponible
        output += `Étape 1: Interpolation pour surface = ${surfacesUtilisees[0]}m²\n`;
        
        let pourcentageEtape1;
        if (distanceInferieure === distanceSuperieure) {
            if (!avecGicleurs) {
                pourcentageEtape1 = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceInferieureIndex];
                output += `À DL de ${distanceInferieure}m et surface de ${surfacesUtilisees[0]}m²: ${pourcentageEtape1}%\n\n`;
            } else {
                pourcentageEtape1 = tableauUtilise[surfacesUtilisees[0]][distanceInferieureIndex];
                output += `À DL de ${distanceInferieure}m et surface de ${surfacesUtilisees[0]}m²: ${pourcentageEtape1}%\n\n`;
            }
        } else {
            if (!avecGicleurs) {
                const pourcentageDistInf = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceInferieureIndex];
                const pourcentageDistSup = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceSuperieureIndex];
                
                output += `À DL de ${distanceInferieure}m et surface de ${surfacesUtilisees[0]}m²: ${pourcentageDistInf}%\n`;
                output += `À DL de ${distanceSuperieure}m et surface de ${surfacesUtilisees[0]}m²: ${pourcentageDistSup}%\n`;
                
                pourcentageEtape1 = pourcentageDistInf + 
                    ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                    (pourcentageDistSup - pourcentageDistInf);
                
                output += `Interpolation: ${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageEtape1.toFixed(2)}%\n\n`;
            } else {
                const pourcentageDistInf = tableauUtilise[surfacesUtilisees[0]][distanceInferieureIndex];
                const pourcentageDistSup = tableauUtilise[surfacesUtilisees[0]][distanceSuperieureIndex];
                
                output += `À DL de ${distanceInferieure}m et surface de ${surfacesUtilisees[0]}m²: ${pourcentageDistInf}%\n`;
                output += `À DL de ${distanceSuperieure}m et surface de ${surfacesUtilisees[0]}m²: ${pourcentageDistSup}%\n`;
                
                pourcentageEtape1 = pourcentageDistInf + 
                    ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                    (pourcentageDistSup - pourcentageDistInf);
                
                output += `Interpolation: ${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageEtape1.toFixed(2)}%\n\n`;
            }
        }
        
        // Étape 2: Calcul pour la 2ème surface disponible
        output += `Étape 2: Interpolation pour surface = ${surfacesUtilisees[1]}m²\n`;
        
        let pourcentageEtape2;
        if (distanceInferieure === distanceSuperieure) {
            if (!avecGicleurs) {
                pourcentageEtape2 = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceInferieureIndex];
                output += `À DL de ${distanceInferieure}m et surface de ${surfacesUtilisees[1]}m²: ${pourcentageEtape2}%\n\n`;
            } else {
                pourcentageEtape2 = tableauUtilise[surfacesUtilisees[1]][distanceInferieureIndex];
                output += `À DL de ${distanceInferieure}m et surface de ${surfacesUtilisees[1]}m²: ${pourcentageEtape2}%\n\n`;
            }
        } else {
            if (!avecGicleurs) {
                const pourcentageDistInf = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceInferieureIndex];
                const pourcentageDistSup = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceSuperieureIndex];
                
                output += `À DL de ${distanceInferieure}m et surface de ${surfacesUtilisees[1]}m²: ${pourcentageDistInf}%\n`;
                output += `À DL de ${distanceSuperieure}m et surface de ${surfacesUtilisees[1]}m²: ${pourcentageDistSup}%\n`;
                
                pourcentageEtape2 = pourcentageDistInf + 
                    ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                    (pourcentageDistSup - pourcentageDistInf);
                
                output += `Interpolation: ${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageEtape2.toFixed(2)}%\n\n`;
            } else {
                const pourcentageDistInf = tableauUtilise[surfacesUtilisees[1]][distanceInferieureIndex];
                const pourcentageDistSup = tableauUtilise[surfacesUtilisees[1]][distanceSuperieureIndex];
                
                output += `À DL de ${distanceInferieure}m et surface de ${surfacesUtilisees[1]}m²: ${pourcentageDistInf}%\n`;
                output += `À DL de ${distanceSuperieure}m et surface de ${surfacesUtilisees[1]}m²: ${pourcentageDistSup}%\n`;
                
                pourcentageEtape2 = pourcentageDistInf + 
                    ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                    (pourcentageDistSup - pourcentageDistInf);
                
                output += `Interpolation: ${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageEtape2.toFixed(2)}%\n\n`;
            }
        }
        
        // Étape 3: Extrapolation pour la surface réelle
        output += `Étape 3: Extrapolation pour surface = ${facadeSurface.toFixed(2)}m²\n`;
        
        const pourcentageFinal = pourcentageEtape2 + 
            ((facadeSurface - surfacesUtilisees[1]) / (surfacesUtilisees[0] - surfacesUtilisees[1])) * 
            (pourcentageEtape1 - pourcentageEtape2);
        
        output += `${pourcentageEtape2.toFixed(2)} + (${facadeSurface.toFixed(2)} - ${surfacesUtilisees[1]}) / (${surfacesUtilisees[0]} - ${surfacesUtilisees[1]}) × (${pourcentageEtape1.toFixed(2)} - ${pourcentageEtape2.toFixed(2)}) = ${pourcentageFinal.toFixed(2)}%\n`;
        
        return output;
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        output += "\nCas d'une seule distance limitative (pas d'interpolation de distance nécessaire)\n\n";
        
        if (!avecGicleurs) {
            const pourcentageSurfInf = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
            const pourcentageSurfSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceInferieureIndex];
            
            output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${surfaceInferieure}m²: ${pourcentageSurfInf}%\n`;
            output += `Étape 2: À DL de ${distanceInferieure}m et surface de ${surfaceSuperieure}m²: ${pourcentageSurfSup}%\n\n`;
            
            // Interpolation entre les surfaces
            const pourcentageFinal = pourcentageSurfSup + 
                ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
                (pourcentageSurfInf - pourcentageSurfSup);
            
            output += `Étape 3: Interpolation pour surface = ${facadeSurface.toFixed(2)}m²\n`;
            output += `${pourcentageSurfSup} + (${facadeSurface.toFixed(2)} - ${surfaceInferieure}) / (${surfaceSuperieure} - ${surfaceInferieure}) × (${pourcentageSurfInf} - ${pourcentageSurfSup}) = ${pourcentageFinal.toFixed(2)}%\n`;
        } else {
            const pourcentageSurfInf = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
            const pourcentageSurfSup = tableauUtilise[surfaceSuperieure][distanceInferieureIndex];
            
            output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${surfaceInferieure}m²: ${pourcentageSurfInf}%\n`;
            output += `Étape 2: À DL de ${distanceInferieure}m et surface de ${surfaceSuperieure}m²: ${pourcentageSurfSup}%\n\n`;
            
            // Interpolation entre les surfaces
            const pourcentageFinal = pourcentageSurfSup + 
                ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
                (pourcentageSurfInf - pourcentageSurfSup);
            
            output += `Étape 3: Interpolation pour surface = ${facadeSurface.toFixed(2)}m²\n`;
            output += `${pourcentageSurfSup} + (${facadeSurface.toFixed(2)} - ${surfaceInferieure}) / (${surfaceSuperieure} - ${surfaceInferieure}) × (${pourcentageSurfInf} - ${pourcentageSurfSup}) = ${pourcentageFinal.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // Si les surfaces sont identiques, pas besoin d'interpolation complexe
    if (surfaceInferieure === surfaceSuperieure) {
        output += "\nCas d'une seule surface (pas d'interpolation de surface nécessaire)\n\n";
        
        if (!avecGicleurs) {
            const pourcentageDistInf = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
            const pourcentageDistSup = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
            
            output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${surfaceInferieure}m²: ${pourcentageDistInf}%\n`;
            output += `Étape 2: À DL de ${distanceSuperieure}m et surface de ${surfaceInferieure}m²: ${pourcentageDistSup}%\n\n`;
            
            // Interpolation entre les distances
            const pourcentageFinal = pourcentageDistInf + 
                ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                (pourcentageDistSup - pourcentageDistInf);
            
            output += `Étape 3: Interpolation pour DL = ${limitingDistance.toFixed(2)}m\n`;
            output += `${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageFinal.toFixed(2)}%\n`;
        } else {
            const pourcentageDistInf = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
            const pourcentageDistSup = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
            
            output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${surfaceInferieure}m²: ${pourcentageDistInf}%\n`;
            output += `Étape 2: À DL de ${distanceSuperieure}m et surface de ${surfaceInferieure}m²: ${pourcentageDistSup}%\n\n`;
            
            // Interpolation entre les distances
            const pourcentageFinal = pourcentageDistInf + 
                ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                (pourcentageDistSup - pourcentageDistInf);
            
            output += `Étape 3: Interpolation pour DL = ${limitingDistance.toFixed(2)}m\n`;
            output += `${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageFinal.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    output += "\nÉtape 1: Interpolation selon la DL encadrante inférieure (" + distanceInferieure + "m):\n";
    
    if (!avecGicleurs) {
        output += `À DL de ${distanceInferieure}m et surface max. de ${surfaceInferieure}m²: ${tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex]}%\n`;
        output += `À DL de ${distanceInferieure}m et surface max. de ${surfaceSuperieure}m²: ${tableauUtilise[surfaceSuperieure][rapportLH][distanceInferieureIndex]}%\n`;
        
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][rapportLH][distanceInferieureIndex];
        
        const etape1 = pourcentageSurfSupDistInf + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
        
        output += `${pourcentageSurfSupDistInf} + (${facadeSurface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) × (${pourcentageSurfInfDistInf} – ${pourcentageSurfSupDistInf}) = `;
        output += `${pourcentageSurfSupDistInf} + ${((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf)).toFixed(2)} = ${etape1.toFixed(2)} %\n`;
    } else {
        output += `À DL de ${distanceInferieure}m et surface max. de ${surfaceInferieure}m²: ${tableauUtilise[surfaceInferieure][distanceInferieureIndex]}%\n`;
        output += `À DL de ${distanceInferieure}m et surface max. de ${surfaceSuperieure}m²: ${tableauUtilise[surfaceSuperieure][distanceInferieureIndex]}%\n`;
        
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][distanceInferieureIndex];
        
        const etape1 = pourcentageSurfSupDistInf + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
        
        output += `${pourcentageSurfSupDistInf} + (${facadeSurface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) × (${pourcentageSurfInfDistInf} – ${pourcentageSurfSupDistInf}) = ${etape1.toFixed(2)} %\n`;
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    output += "\nÉtape 2: Interpolation selon la DL encadrante supérieure (" + distanceSuperieure + "m):\n";
    
    if (!avecGicleurs) {
        output += `À DL de ${distanceSuperieure}m et surface max. de ${surfaceInferieure}m²: ${tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex]}%\n`;
        output += `À DL de ${distanceSuperieure}m et surface max. de ${surfaceSuperieure}m²: ${tableauUtilise[surfaceSuperieure][rapportLH][distanceSuperieureIndex]}%\n`;
        
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceSuperieureIndex];
        
        const etape2 = pourcentageSurfSupDistSup + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
        
        output += `${pourcentageSurfSupDistSup} + (${facadeSurface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) × (${pourcentageSurfInfDistSup} – ${pourcentageSurfSupDistSup}) = ${etape2.toFixed(2)} %\n`;
    } else {
        output += `À DL de ${distanceSuperieure}m et surface max. de ${surfaceInferieure}m²: ${tableauUtilise[surfaceInferieure][distanceSuperieureIndex]}%\n`;
        output += `À DL de ${distanceSuperieure}m et surface max. de ${surfaceSuperieure}m²: ${tableauUtilise[surfaceSuperieure][distanceSuperieureIndex]}%\n`;
        
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][distanceSuperieureIndex];
        
        const etape2 = pourcentageSurfSupDistSup + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
        
        output += `${pourcentageSurfSupDistSup} + (${facadeSurface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) × (${pourcentageSurfInfDistSup} – ${pourcentageSurfSupDistSup}) = ${etape2.toFixed(2)} %\n`;
    }
    
    // ÉTAPE 3: Interpolation finale entre les deux résultats d'interpolation précédents
    output += "\nÉtape 3: Interpolation selon les résultats obtenus des deux interpolations précédentes:\n";
    
    // Calcul préliminaire pour récupérer les valeurs à interpoler
    let pourcentageDistanceInferieure, pourcentageDistanceSuperieure;
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][rapportLH][distanceInferieureIndex];
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceSuperieureIndex];
        
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
            
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
    } else {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][distanceInferieureIndex];
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][distanceSuperieureIndex];
        
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
            
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
    }
    
    const pourcentageFinal = pourcentageDistanceInferieure + 
        ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
        
    output += `${pourcentageDistanceInferieure.toFixed(2)} + (${limitingDistance.toFixed(2)} – ${distanceInferieure}) / (${distanceSuperieure} – ${distanceInferieure}) × (${pourcentageDistanceSuperieure.toFixed(2)} – ${pourcentageDistanceInferieure.toFixed(2)}) = `;
    output += `${pourcentageDistanceInferieure.toFixed(2)} + ${((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure) * (pourcentageDistanceSuperieure - pourcentageDistanceInferieure)).toFixed(2)} = ${pourcentageFinal.toFixed(2)} %\n`;
    
    return output;
}

// Fonction pour formater les calculs pour la méthode 9.10.14
function format91014CalculationSteps() {
    // Déterminer le système de mesure et récupérer les valeurs
    const isImperial = document.getElementById('measurementSystem').value === 'imperial';
    
    let limitingDistance, surface;
    
    if (isImperial) {
        limitingDistance = imperialToMetric(document.getElementById('distance_91014_imperial').value);
        surface = imperialToMetric(document.getElementById('surface_91014_imperial').value, "area");
    } else {
        limitingDistance = parseFloat(document.getElementById('distance_91014').value);
        surface = parseFloat(document.getElementById('surface_91014').value);
    }
    
    const usage = document.getElementById('usage_91014').value;
    const sprinklersOption = document.getElementById('sprinklers_91014').value;
    const glassBrick = document.getElementById('glass_brick_91014').checked;
    const response = document.getElementById('response_91014').checked;
    
    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }
    
    // Préparer le texte formaté
    let output = "Tableau 9.10.14.4.-A:\n";
    output += `DL: ${limitingDistance.toFixed(2)}m\n`;
    output += `Surface de la FDR: ${surface.toFixed(2)}m²\n\n`;
    
    // Déterminer les distances et surfaces disponibles
    const tableau = {
        usages: usage,
        surfaces: tableau91014[usage].surfaces,
        distances: tableau91014[usage].distances
    };
    
    // Extraire les distances et surfaces disponibles
    const distances = tableau.distances;
    const surfacesDisponibles = Object.keys(tableau.surfaces).filter(s => s !== ">100").map(Number);
    
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(limitingDistance, distances);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distances.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distances.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Trouver les surfaces encadrantes
    let surfaceInferieure, surfaceSuperieure;
    let keyInf, keySup;
    
    if (surface <= surfacesDisponibles[0]) {
        // Cas d'extrapolation pour petites surfaces
        if (surface < surfacesDisponibles[0]) {
            surfaceInferieure = surface;
            surfaceSuperieure = surfacesDisponibles[0];
            keyInf = "extrapolation";
            keySup = surfacesDisponibles[0].toString();
        } else {
            surfaceInferieure = surfaceSuperieure = surfacesDisponibles[0];
            keyInf = keySup = surfacesDisponibles[0].toString();
        }
    } else if (surface > surfacesDisponibles[surfacesDisponibles.length - 1]) {
        surfaceInferieure = surfacesDisponibles[surfacesDisponibles.length - 1];
        surfaceSuperieure = Infinity;
        keyInf = surfacesDisponibles[surfacesDisponibles.length - 1].toString();
        keySup = ">100";
    } else {
        for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
            if (surface > surfacesDisponibles[i] && surface <= surfacesDisponibles[i + 1]) {
                surfaceInferieure = surfacesDisponibles[i];
                surfaceSuperieure = surfacesDisponibles[i + 1];
                keyInf = surfaceInferieure.toString();
                keySup = surfaceSuperieure.toString();
                break;
            }
        }
    }
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        output += "Cas spécial: Extrapolation pour distance limitative entre 0 et " + distanceSuperieure + "m\n\n";
        
        output += "Étape 1: Calcul à DL = 0m\n";
        output += "À DL = 0m, le pourcentage de baies non protégées est toujours de 0%\n\n";
        
        output += "Étape 2: Calcul à DL = " + distanceSuperieure + "m\n";
        
        if (keyInf === "extrapolation") {
            // Double extrapolation (distance et surface)
            output += "Cas de double extrapolation (distance et surface)\n";
            
            const pourcentageDistMinSurfMin = tableau.surfaces[keySup][distanceSuperieureIndex];
            const pourcentageDistMinSurfSupMin = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceSuperieureIndex];
            
            output += `À DL de ${distanceSuperieure}m et surface min. du tableau de ${keySup}m²: ${pourcentageDistMinSurfMin}%\n`;
            output += `À DL de ${distanceSuperieure}m et surface suivante du tableau de ${Object.keys(tableau.surfaces)[1]}m²: ${pourcentageDistMinSurfSupMin}%\n`;
            
            // Calcul d'extrapolation pour surface plus petite
            const tendance = pourcentageDistMinSurfMin - pourcentageDistMinSurfSupMin;
            const ratio = parseInt(keySup) / surface;
            const facteur = Math.sqrt(ratio);
            const extrapolation = pourcentageDistMinSurfMin + tendance * (facteur - 1);
            
            output += `Extrapolation pour surface de ${surface.toFixed(2)}m²: ${pourcentageDistMinSurfMin} + (${tendance.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${extrapolation.toFixed(2)}%\n\n`;
            
            output += "Étape 3: Extrapolation finale pour DL = " + limitingDistance.toFixed(2) + "m\n";
            const pourcentageFinal = extrapolerPourcentage(0, extrapolation, distanceSuperieure, limitingDistance);
            output += `0 + (${extrapolation.toFixed(2)} - 0) × (${limitingDistance.toFixed(2)} / ${distanceSuperieure}) = ${pourcentageFinal.toFixed(2)}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
            
            return output;
        } else {
            // Extrapolation simple pour la distance uniquement
            const pourcentageDistMin = tableau.surfaces[keyInf][distanceSuperieureIndex];
            output += `À DL de ${distanceSuperieure}m et surface de ${keyInf}m²: ${pourcentageDistMin}%\n\n`;
            
            output += "Étape 3: Extrapolation finale pour DL = " + limitingDistance.toFixed(2) + "m\n";
            const pourcentageFinal = extrapolerPourcentage(0, pourcentageDistMin, distanceSuperieure, limitingDistance);
            output += `0 + (${pourcentageDistMin} - 0) × (${limitingDistance.toFixed(2)} / ${distanceSuperieure}) = ${pourcentageFinal.toFixed(2)}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
            
            return output;
        }
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 30m²)
    if (keyInf === "extrapolation") {
        output += "Cas spécial: Extrapolation pour surface inférieure à " + keySup + "m²\n\n";
        
        const pourcentageSurfMin = tableau.surfaces[keySup][distanceInferieureIndex];
        const pourcentageSurfSupMin = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceInferieureIndex];
        
        output += `Étape 1: Calcul à DL = ${distanceInferieure}m\n`;
        output += `À DL de ${distanceInferieure}m et surface min. du tableau de ${keySup}m²: ${pourcentageSurfMin}%\n`;
        output += `À DL de ${distanceInferieure}m et surface suivante du tableau de ${Object.keys(tableau.surfaces)[1]}m²: ${pourcentageSurfSupMin}%\n`;
        
        // Calcul d'extrapolation pour surface plus petite
        const tendance = pourcentageSurfMin - pourcentageSurfSupMin;
        const ratio = parseInt(keySup) / surface;
        const facteur = Math.sqrt(ratio);
        const etape1 = pourcentageSurfMin + tendance * (facteur - 1);
        
        output += `Extrapolation pour surface de ${surface.toFixed(2)}m²: ${pourcentageSurfMin} + (${tendance.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${etape1.toFixed(2)}%\n\n`;
        
        // Étape 2 si nécessaire (si distance supérieure différente)
        if (distanceInferieure !== distanceSuperieure) {
            const pourcentageSurfMinSup = tableau.surfaces[keySup][distanceSuperieureIndex];
            const pourcentageSurfSupMinSup = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceSuperieureIndex];
            
            output += `Étape 2: Calcul à DL = ${distanceSuperieure}m\n`;
            output += `À DL de ${distanceSuperieure}m et surface min. du tableau de ${keySup}m²: ${pourcentageSurfMinSup}%\n`;
            output += `À DL de ${distanceSuperieure}m et surface suivante du tableau de ${Object.keys(tableau.surfaces)[1]}m²: ${pourcentageSurfSupMinSup}%\n`;
            
            const tendanceSup = pourcentageSurfMinSup - pourcentageSurfSupMinSup;
            const etape2 = pourcentageSurfMinSup + tendanceSup * (facteur - 1);
            
            output += `Extrapolation pour surface de ${surface.toFixed(2)}m²: ${pourcentageSurfMinSup} + (${tendanceSup.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${etape2.toFixed(2)}%\n\n`;
            
            output += `Étape 3: Interpolation finale pour DL = ${limitingDistance.toFixed(2)}m\n`;
            const pourcentageFinal = etape1 + 
                ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                (etape2 - etape1);
            
            output += `${etape1.toFixed(2)} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${etape2.toFixed(2)} - ${etape1.toFixed(2)}) = ${pourcentageFinal.toFixed(2)}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
        } else {
            // Une seule distance, l'extrapolation est déjà faite
            output += `Étape 3: Le résultat final est ${etape1.toFixed(2)}% (pas d'interpolation de distance nécessaire)\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, etape1 * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${etape1.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
        }
        
        return output;
    }
    
    // Cas spécial pour FDR petite et DL >= DL minimale non-nulle
    const premiereDLNonNulle = distances.find(d => d > 0);
    if (surface < surfacesDisponibles[0] && limitingDistance >= premiereDLNonNulle) {
        output += "Cas spécial: Extrapolation pour petite surface avec DL normale\n\n";
        
        // Étape 1: Calcul pour la 1ère surface disponible
        output += `Étape 1: Interpolation pour surface = ${surfacesDisponibles[0]}m²\n`;
        
        let pourcentageEtape1;
        if (distanceInferieure === distanceSuperieure) {
            pourcentageEtape1 = tableau.surfaces[surfacesDisponibles[0].toString()][distanceInferieureIndex];
            output += `À DL de ${distanceInferieure}m et surface de ${surfacesDisponibles[0]}m²: ${pourcentageEtape1}%\n\n`;
        } else {
            const pourcentageDistInf = tableau.surfaces[surfacesDisponibles[0].toString()][distanceInferieureIndex];
            const pourcentageDistSup = tableau.surfaces[surfacesDisponibles[0].toString()][distanceSuperieureIndex];
            
            output += `À DL de ${distanceInferieure}m et surface de ${surfacesDisponibles[0]}m²: ${pourcentageDistInf}%\n`;
            output += `À DL de ${distanceSuperieure}m et surface de ${surfacesDisponibles[0]}m²: ${pourcentageDistSup}%\n`;
            
            pourcentageEtape1 = pourcentageDistInf + 
                ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                (pourcentageDistSup - pourcentageDistInf);
            
            output += `Interpolation: ${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageEtape1.toFixed(2)}%\n\n`;
        }
        
        // Étape 2: Calcul pour la 2ème surface disponible
        output += `Étape 2: Interpolation pour surface = ${surfacesDisponibles[1]}m²\n`;
        
        let pourcentageEtape2;
        if (distanceInferieure === distanceSuperieure) {
            pourcentageEtape2 = tableau.surfaces[surfacesDisponibles[1].toString()][distanceInferieureIndex];
            output += `À DL de ${distanceInferieure}m et surface de ${surfacesDisponibles[1]}m²: ${pourcentageEtape2}%\n\n`;
        } else {
            const pourcentageDistInf = tableau.surfaces[surfacesDisponibles[1].toString()][distanceInferieureIndex];
            const pourcentageDistSup = tableau.surfaces[surfacesDisponibles[1].toString()][distanceSuperieureIndex];
            
            output += `À DL de ${distanceInferieure}m et surface de ${surfacesDisponibles[1]}m²: ${pourcentageDistInf}%\n`;
            output += `À DL de ${distanceSuperieure}m et surface de ${surfacesDisponibles[1]}m²: ${pourcentageDistSup}%\n`;
            
            pourcentageEtape2 = pourcentageDistInf + 
                ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                (pourcentageDistSup - pourcentageDistInf);
            
            output += `Interpolation: ${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageEtape2.toFixed(2)}%\n\n`;
        }
        
        // Étape 3: Extrapolation pour la surface réelle
        output += `Étape 3: Extrapolation pour surface = ${surface.toFixed(2)}m²\n`;
        
        const pourcentageFinal = pourcentageEtape2 + 
            ((surface - surfacesDisponibles[1]) / (surfacesDisponibles[0] - surfacesDisponibles[1])) * 
            (pourcentageEtape1 - pourcentageEtape2);
        
        output += `${pourcentageEtape2.toFixed(2)} + (${surface.toFixed(2)} - ${surfacesDisponibles[1]}) / (${surfacesDisponibles[0]} - ${surfacesDisponibles[1]}) × (${pourcentageEtape1.toFixed(2)} - ${pourcentageEtape2.toFixed(2)}) = ${pourcentageFinal.toFixed(2)}%\n`;
        
        // Si nécessaire, appliquer la majoration
        if (sprinklersOption === "complete" || glassBrick) {
            const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
            output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        output += "Cas d'une seule distance limitative (pas d'interpolation de distance nécessaire)\n\n";
        
        if (keyInf === keySup) {
            output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${keyInf}m²: ${tableau.surfaces[keyInf][distanceInferieureIndex]}%\n`;
            
            let pourcentageFinal = tableau.surfaces[keyInf][distanceInferieureIndex];
            output += `\nÉtape 2 et 3: Non nécessaires (surface et distance uniques)\n`;
            output += `Résultat final: ${pourcentageFinal}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
        } else {
            const pourcentageSurfInf = tableau.surfaces[keyInf][distanceInferieureIndex];
            const pourcentageSurfSup = tableau.surfaces[keySup][distanceInferieureIndex];
            
            output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${keyInf}m²: ${pourcentageSurfInf}%\n`;
            output += `Étape 2: À DL de ${distanceInferieure}m et surface de ${keySup === ">100" ? "plus de 100" : keySup}m²: ${pourcentageSurfSup}%\n\n`;
            
            // Interpolation entre les surfaces
            const pourcentageFinal = pourcentageSurfSup + 
                ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
                (pourcentageSurfInf - pourcentageSurfSup);
            
            output += `Étape 3: Interpolation pour surface = ${surface.toFixed(2)}m²\n`;
            output += `${pourcentageSurfSup} + (${surface.toFixed(2)} - ${surfaceInferieure}) / (${keySup === ">100" ? "Surface maximale du tableau" : surfaceSuperieure} - ${surfaceInferieure}) × (${pourcentageSurfInf} - ${pourcentageSurfSup}) = ${pourcentageFinal.toFixed(2)}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
        }
        
        return output;
    }
    
    // Si les surfaces sont identiques, pas besoin d'interpolation complexe
    if (keyInf === keySup) {
        output += "Cas d'une seule surface (pas d'interpolation de surface nécessaire)\n\n";
        
        const pourcentageDistInf = tableau.surfaces[keyInf][distanceInferieureIndex];
        const pourcentageDistSup = tableau.surfaces[keyInf][distanceSuperieureIndex];
        
        output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${keyInf}m²: ${pourcentageDistInf}%\n`;
        output += `Étape 2: À DL de ${distanceSuperieure}m et surface de ${keyInf}m²: ${pourcentageDistSup}%\n\n`;
        
        // Interpolation entre les distances
        const pourcentageFinal = pourcentageDistInf + 
            ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
            (pourcentageDistSup - pourcentageDistInf);
        
        output += `Étape 3: Interpolation pour DL = ${limitingDistance.toFixed(2)}m\n`;
        output += `${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageFinal.toFixed(2)}%\n`;
        
        // Si nécessaire, appliquer la majoration
        if (sprinklersOption === "complete" || glassBrick) {
            const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
            output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    output += "Étape 1: Interpolation selon la DL encadrante inférieure (" + distanceInferieure + "m):\n";
    
    const pourcentageDistInfSurfInf = tableau.surfaces[keyInf][distanceInferieureIndex];
    const pourcentageDistInfSurfSup = tableau.surfaces[keySup][distanceInferieureIndex];
    
    output += `À DL de ${distanceInferieure}m et surface max. de ${keyInf}m²: ${pourcentageDistInfSurfInf}%\n`;
    output += `À DL de ${distanceInferieure}m et surface max. de ${keySup === ">100" ? "plus de 100" : keySup}m²: ${pourcentageDistInfSurfSup}%\n`;
    
    const pourcentageEtape1 = pourcentageDistInfSurfSup + 
        ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
        (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup);
    
    output += `${pourcentageDistInfSurfSup} + (${surface.toFixed(2)} – ${surfaceInferieure}) / (${keySup === ">100" ? "Surface maximale du tableau" : surfaceSuperieure} – ${surfaceInferieure}) × (${pourcentageDistInfSurfInf} – ${pourcentageDistInfSurfSup}) = ${pourcentageEtape1.toFixed(2)} %\n\n`;

    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    output += "Étape 2: Interpolation selon la DL encadrante supérieure (" + distanceSuperieure + "m):\n";
    
    const pourcentageDistSupSurfInf = tableau.surfaces[keyInf][distanceSuperieureIndex];
    const pourcentageDistSupSurfSup = tableau.surfaces[keySup][distanceSuperieureIndex];
    
    output += `À DL de ${distanceSuperieure}m et surface max. de ${keyInf}m²: ${pourcentageDistSupSurfInf}%\n`;
    output += `À DL de ${distanceSuperieure}m et surface max. de ${keySup === ">100" ? "plus de 100" : keySup}m²: ${pourcentageDistSupSurfSup}%\n`;
    
    const pourcentageEtape2 = pourcentageDistSupSurfSup + 
        ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
        (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup);
    
    output += `${pourcentageDistSupSurfSup} + (${surface.toFixed(2)} – ${surfaceInferieure}) / (${keySup === ">100" ? "Surface maximale du tableau" : surfaceSuperieure} – ${surfaceInferieure}) × (${pourcentageDistSupSurfInf} – ${pourcentageDistSupSurfSup}) = ${pourcentageEtape2.toFixed(2)} %\n\n`;
    
    // ÉTAPE 3: Interpolation finale
    output += "Étape 3: Interpolation selon les résultats obtenus des deux interpolations précédentes:\n";
    
    let pourcentageFinal = pourcentageEtape1 + 
        ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageEtape2 - pourcentageEtape1);
        
    output += `${pourcentageEtape1.toFixed(2)} + (${limitingDistance.toFixed(2)} – ${distanceInferieure}) / (${distanceSuperieure} – ${distanceInferieure}) × (${pourcentageEtape2.toFixed(2)} – ${pourcentageEtape1.toFixed(2)}) = ${pourcentageFinal.toFixed(2)} %\n`;
    
    // Vérifier si on applique la formule spéciale pour les grandes surfaces
    if (surface > surfacesDisponibles[surfacesDisponibles.length - 1] && limitingDistance >= 1.2) {
        // Pour le tableau 9.10.14.4-A avec usage "habitation" ou pour 9.10.15.4
        if (usage === "habitation") {
            const valeurFormule = Math.pow(limitingDistance, 2);
            output += `\nFormule spéciale pour grande surface (>100 m²) avec DL ≥ 1,2 m: DL² = ${limitingDistance.toFixed(2)}² = ${valeurFormule.toFixed(2)}%\n`;
            pourcentageFinal = valeurFormule;
        } else { // Pour le tableau 9.10.14.4-A avec usage "commercial"
            const valeurFormule = 0.5 * Math.pow(limitingDistance, 2);
            output += `\nFormule spéciale pour grande surface (>100 m²) avec DL ≥ 1,2 m: 0,5 × DL² = 0,5 × ${limitingDistance.toFixed(2)}² = ${valeurFormule.toFixed(2)}%\n`;
            pourcentageFinal = valeurFormule;
        }
    }
    
    // Si nécessaire, appliquer la majoration
    if (sprinklersOption === "complete" || glassBrick) {
        const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
        output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
    }
    
    return output;
}

// Fonction pour formater les calculs pour la méthode 9.10.15
function format91015CalculationSteps() {
    // Cette fonction sera très similaire à format91014CalculationSteps
    // Déterminer le système de mesure et récupérer les valeurs
    const isImperial = document.getElementById('measurementSystem').value === 'imperial';
    
    let limitingDistance, surface;
    
    if (isImperial) {
        limitingDistance = imperialToMetric(document.getElementById('distance_91015_imperial').value);
        surface = imperialToMetric(document.getElementById('surface_91015_imperial').value, "area");
    } else {
        limitingDistance = parseFloat(document.getElementById('distance_91015').value);
        surface = parseFloat(document.getElementById('surface_91015').value);
    }
    
    const sprinklersOption = document.getElementById('sprinklers_91015').value;
    const glassBrick = document.getElementById('glass_brick_91015').checked;
    const response = document.getElementById('response_91015').checked;
    
    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }
    
    // Préparer le texte formaté
    let output = "Tableau 9.10.15.4.:\n";
    output += `DL: ${limitingDistance.toFixed(2)}m\n`;
    output += `Surface de la FDR: ${surface.toFixed(2)}m²\n\n`;
    
    // Extraire les distances et surfaces disponibles
    const distances = tableau91015.distances;
    const surfacesDisponibles = Object.keys(tableau91015.surfaces).filter(s => s !== ">100").map(Number);
    
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(limitingDistance, distances);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distances.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distances.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Trouver les surfaces encadrantes
    let surfaceInferieure, surfaceSuperieure;
    let keyInf, keySup;
    
    if (surface <= surfacesDisponibles[0]) {
        // Cas d'extrapolation pour petites surfaces
        if (surface < surfacesDisponibles[0]) {
            surfaceInferieure = surface;
            surfaceSuperieure = surfacesDisponibles[0];
            keyInf = "extrapolation";
            keySup = surfacesDisponibles[0].toString();
        } else {
            surfaceInferieure = surfaceSuperieure = surfacesDisponibles[0];
            keyInf = keySup = surfacesDisponibles[0].toString();
        }
    } else if (surface > surfacesDisponibles[surfacesDisponibles.length - 1]) {
        surfaceInferieure = surfacesDisponibles[surfacesDisponibles.length - 1];
        surfaceSuperieure = Infinity;
        keyInf = surfacesDisponibles[surfacesDisponibles.length - 1].toString();
        keySup = ">100";
    } else {
        for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
            if (surface > surfacesDisponibles[i] && surface <= surfacesDisponibles[i + 1]) {
                surfaceInferieure = surfacesDisponibles[i];
                surfaceSuperieure = surfacesDisponibles[i + 1];
                keyInf = surfaceInferieure.toString();
                keySup = surfaceSuperieure.toString();
                break;
            }
        }
    }
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        output += "Cas spécial: Extrapolation pour distance limitative entre 0 et " + distanceSuperieure + "m\n\n";
        
        output += "Étape 1: Calcul à DL = 0m\n";
        output += "À DL = 0m, le pourcentage de baies non protégées est toujours de 0%\n\n";
        
        output += "Étape 2: Calcul à DL = " + distanceSuperieure + "m\n";
        
        if (keyInf === "extrapolation") {
            // Double extrapolation (distance et surface)
            output += "Cas de double extrapolation (distance et surface)\n";
            
            const pourcentageDistMinSurfMin = tableau91015.surfaces[keySup][distanceSuperieureIndex];
            const pourcentageDistMinSurfSupMin = tableau91015.surfaces[Object.keys(tableau91015.surfaces)[1]][distanceSuperieureIndex];
            
            output += `À DL de ${distanceSuperieure}m et surface min. du tableau de ${keySup}m²: ${pourcentageDistMinSurfMin}%\n`;
            output += `À DL de ${distanceSuperieure}m et surface suivante du tableau de ${Object.keys(tableau91015.surfaces)[1]}m²: ${pourcentageDistMinSurfSupMin}%\n`;
            
            // Calcul d'extrapolation pour surface plus petite
            const tendance = pourcentageDistMinSurfMin - pourcentageDistMinSurfSupMin;
            const ratio = parseInt(keySup) / surface;
            const facteur = Math.sqrt(ratio);
            const extrapolation = pourcentageDistMinSurfMin + tendance * (facteur - 1);
            
            output += `Extrapolation pour surface de ${surface.toFixed(2)}m²: ${pourcentageDistMinSurfMin} + (${tendance.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${extrapolation.toFixed(2)}%\n\n`;
            
            output += "Étape 3: Extrapolation finale pour DL = " + limitingDistance.toFixed(2) + "m\n";
            const pourcentageFinal = extrapolerPourcentage(0, extrapolation, distanceSuperieure, limitingDistance);
            output += `0 + (${extrapolation.toFixed(2)} - 0) × (${limitingDistance.toFixed(2)} / ${distanceSuperieure}) = ${pourcentageFinal.toFixed(2)}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
            
            return output;
        } else {
            // Extrapolation simple pour la distance uniquement
            const pourcentageDistMin = tableau91015.surfaces[keyInf][distanceSuperieureIndex];
            output += `À DL de ${distanceSuperieure}m et surface de ${keyInf}m²: ${pourcentageDistMin}%\n\n`;
            
            output += "Étape 3: Extrapolation finale pour DL = " + limitingDistance.toFixed(2) + "m\n";
            const pourcentageFinal = extrapolerPourcentage(0, pourcentageDistMin, distanceSuperieure, limitingDistance);
            output += `0 + (${pourcentageDistMin} - 0) × (${limitingDistance.toFixed(2)} / ${distanceSuperieure}) = ${pourcentageFinal.toFixed(2)}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
            
            return output;
        }
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 30m²)
    if (keyInf === "extrapolation") {
        output += "Cas spécial: Extrapolation pour surface inférieure à " + keySup + "m²\n\n";
        
        const pourcentageSurfMin = tableau91015.surfaces[keySup][distanceInferieureIndex];
        const pourcentageSurfSupMin = tableau91015.surfaces[Object.keys(tableau91015.surfaces)[1]][distanceInferieureIndex];
        
        output += `Étape 1: Calcul à DL = ${distanceInferieure}m\n`;
        output += `À DL de ${distanceInferieure}m et surface min. du tableau de ${keySup}m²: ${pourcentageSurfMin}%\n`;
        output += `À DL de ${distanceInferieure}m et surface suivante du tableau de ${Object.keys(tableau91015.surfaces)[1]}m²: ${pourcentageSurfSupMin}%\n`;
        
        // Calcul d'extrapolation pour surface plus petite
        const tendance = pourcentageSurfMin - pourcentageSurfSupMin;
        const ratio = parseInt(keySup) / surface;
        const facteur = Math.sqrt(ratio);
        const etape1 = pourcentageSurfMin + tendance * (facteur - 1);
        
        output += `Extrapolation pour surface de ${surface.toFixed(2)}m²: ${pourcentageSurfMin} + (${tendance.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${etape1.toFixed(2)}%\n\n`;
        
        // Étape 2 si nécessaire (si distance supérieure différente)
        if (distanceInferieure !== distanceSuperieure) {
            const pourcentageSurfMinSup = tableau91015.surfaces[keySup][distanceSuperieureIndex];
            const pourcentageSurfSupMinSup = tableau91015.surfaces[Object.keys(tableau91015.surfaces)[1]][distanceSuperieureIndex];
            
            output += `Étape 2: Calcul à DL = ${distanceSuperieure}m\n`;
            output += `À DL de ${distanceSuperieure}m et surface min. du tableau de ${keySup}m²: ${pourcentageSurfMinSup}%\n`;
            output += `À DL de ${distanceSuperieure}m et surface suivante du tableau de ${Object.keys(tableau91015.surfaces)[1]}m²: ${pourcentageSurfSupMinSup}%\n`;
            
            const tendanceSup = pourcentageSurfMinSup - pourcentageSurfSupMinSup;
            const etape2 = pourcentageSurfMinSup + tendanceSup * (facteur - 1);
            
            output += `Extrapolation pour surface de ${surface.toFixed(2)}m²: ${pourcentageSurfMinSup} + (${tendanceSup.toFixed(2)} × (${facteur.toFixed(2)} - 1)) = ${etape2.toFixed(2)}%\n\n`;
            
            output += `Étape 3: Interpolation finale pour DL = ${limitingDistance.toFixed(2)}m\n`;
            const pourcentageFinal = etape1 + 
                ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                (etape2 - etape1);
            
            output += `${etape1.toFixed(2)} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${etape2.toFixed(2)} - ${etape1.toFixed(2)}) = ${pourcentageFinal.toFixed(2)}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
        } else {
            // Une seule distance, l'extrapolation est déjà faite
            output += `Étape 3: Le résultat final est ${etape1.toFixed(2)}% (pas d'interpolation de distance nécessaire)\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, etape1 * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${etape1.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
        }
        
        return output;
    }
    
    // Cas spécial pour FDR petite et DL >= DL minimale non-nulle
    const premiereDLNonNulle = distances.find(d => d > 0);
    if (surface < surfacesDisponibles[0] && limitingDistance >= premiereDLNonNulle) {
        output += "Cas spécial: Extrapolation pour petite surface avec DL normale\n\n";
        
        // Étape 1: Calcul pour la 1ère surface disponible
        output += `Étape 1: Interpolation pour surface = ${surfacesDisponibles[0]}m²\n`;
        
        let pourcentageEtape1;
        if (distanceInferieure === distanceSuperieure) {
            pourcentageEtape1 = tableau91015.surfaces[surfacesDisponibles[0].toString()][distanceInferieureIndex];
            output += `À DL de ${distanceInferieure}m et surface de ${surfacesDisponibles[0]}m²: ${pourcentageEtape1}%\n\n`;
        } else {
            const pourcentageDistInf = tableau91015.surfaces[surfacesDisponibles[0].toString()][distanceInferieureIndex];
            const pourcentageDistSup = tableau91015.surfaces[surfacesDisponibles[0].toString()][distanceSuperieureIndex];
            
            output += `À DL de ${distanceInferieure}m et surface de ${surfacesDisponibles[0]}m²: ${pourcentageDistInf}%\n`;
            output += `À DL de ${distanceSuperieure}m et surface de ${surfacesDisponibles[0]}m²: ${pourcentageDistSup}%\n`;
            
            pourcentageEtape1 = pourcentageDistInf + 
                ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                (pourcentageDistSup - pourcentageDistInf);
            
            output += `Interpolation: ${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageEtape1.toFixed(2)}%\n\n`;
        }
        
        // Étape 2: Calcul pour la 2ème surface disponible
        output += `Étape 2: Interpolation pour surface = ${surfacesDisponibles[1]}m²\n`;
        
        let pourcentageEtape2;
        if (distanceInferieure === distanceSuperieure) {
            pourcentageEtape2 = tableau91015.surfaces[surfacesDisponibles[1].toString()][distanceInferieureIndex];
            output += `À DL de ${distanceInferieure}m et surface de ${surfacesDisponibles[1]}m²: ${pourcentageEtape2}%\n\n`;
        } else {
            const pourcentageDistInf = tableau91015.surfaces[surfacesDisponibles[1].toString()][distanceInferieureIndex];
            const pourcentageDistSup = tableau91015.surfaces[surfacesDisponibles[1].toString()][distanceSuperieureIndex];
            
            output += `À DL de ${distanceInferieure}m et surface de ${surfacesDisponibles[1]}m²: ${pourcentageDistInf}%\n`;
            output += `À DL de ${distanceSuperieure}m et surface de ${surfacesDisponibles[1]}m²: ${pourcentageDistSup}%\n`;
            
            pourcentageEtape2 = pourcentageDistInf + 
                ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
                (pourcentageDistSup - pourcentageDistInf);
            
            output += `Interpolation: ${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageEtape2.toFixed(2)}%\n\n`;
        }
        
        // Étape 3: Extrapolation pour la surface réelle
        output += `Étape 3: Extrapolation pour surface = ${surface.toFixed(2)}m²\n`;
        
        const pourcentageFinal = pourcentageEtape2 + 
            ((surface - surfacesDisponibles[1]) / (surfacesDisponibles[0] - surfacesDisponibles[1])) * 
            (pourcentageEtape1 - pourcentageEtape2);
        
        output += `${pourcentageEtape2.toFixed(2)} + (${surface.toFixed(2)} - ${surfacesDisponibles[1]}) / (${surfacesDisponibles[0]} - ${surfacesDisponibles[1]}) × (${pourcentageEtape1.toFixed(2)} - ${pourcentageEtape2.toFixed(2)}) = ${pourcentageFinal.toFixed(2)}%\n`;
        
        // Si nécessaire, appliquer la majoration
        if (sprinklersOption === "complete" || glassBrick) {
            const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
            output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        output += "Cas d'une seule distance limitative (pas d'interpolation de distance nécessaire)\n\n";
        
        if (keyInf === keySup) {
            output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${keyInf}m²: ${tableau91015.surfaces[keyInf][distanceInferieureIndex]}%\n`;
            
            let pourcentageFinal = tableau91015.surfaces[keyInf][distanceInferieureIndex];
            output += `\nÉtape 2 et 3: Non nécessaires (surface et distance uniques)\n`;
            output += `Résultat final: ${pourcentageFinal}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
        } else {
            const pourcentageSurfInf = tableau91015.surfaces[keyInf][distanceInferieureIndex];
            const pourcentageSurfSup = tableau91015.surfaces[keySup][distanceInferieureIndex];
            
            output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${keyInf}m²: ${pourcentageSurfInf}%\n`;
            output += `Étape 2: À DL de ${distanceInferieure}m et surface de ${keySup === ">100" ? "plus de 100" : keySup}m²: ${pourcentageSurfSup}%\n\n`;
            
            // Interpolation entre les surfaces
            const pourcentageFinal = pourcentageSurfSup + 
                ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
                (pourcentageSurfInf - pourcentageSurfSup);
            
            output += `Étape 3: Interpolation pour surface = ${surface.toFixed(2)}m²\n`;
            output += `${pourcentageSurfSup} + (${surface.toFixed(2)} - ${surfaceInferieure}) / (${keySup === ">100" ? "Surface maximale du tableau" : surfaceSuperieure} - ${surfaceInferieure}) × (${pourcentageSurfInf} - ${pourcentageSurfSup}) = ${pourcentageFinal.toFixed(2)}%\n`;
            
            // Si nécessaire, appliquer la majoration
            if (sprinklersOption === "complete" || glassBrick) {
                const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
                output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
            }
        }
        
        return output;
    }
    
    // Si les surfaces sont identiques, pas besoin d'interpolation complexe
    if (keyInf === keySup) {
        output += "Cas d'une seule surface (pas d'interpolation de surface nécessaire)\n\n";
        
        const pourcentageDistInf = tableau91015.surfaces[keyInf][distanceInferieureIndex];
        const pourcentageDistSup = tableau91015.surfaces[keyInf][distanceSuperieureIndex];
        
        output += `Étape 1: À DL de ${distanceInferieure}m et surface de ${keyInf}m²: ${pourcentageDistInf}%\n`;
        output += `Étape 2: À DL de ${distanceSuperieure}m et surface de ${keyInf}m²: ${pourcentageDistSup}%\n\n`;
        
        // Interpolation entre les distances
        const pourcentageFinal = pourcentageDistInf + 
            ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
            (pourcentageDistSup - pourcentageDistInf);
        
        output += `Étape 3: Interpolation pour DL = ${limitingDistance.toFixed(2)}m\n`;
        output += `${pourcentageDistInf} + (${limitingDistance.toFixed(2)} - ${distanceInferieure}) / (${distanceSuperieure} - ${distanceInferieure}) × (${pourcentageDistSup} - ${pourcentageDistInf}) = ${pourcentageFinal.toFixed(2)}%\n`;
        
        // Si nécessaire, appliquer la majoration
        if (sprinklersOption === "complete" || glassBrick) {
            const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
            output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure
    output += "Étape 1: Interpolation selon la DL encadrante inférieure (" + distanceInferieure + "m):\n";
    
    const pourcentageDistInfSurfInf = tableau91015.surfaces[keyInf][distanceInferieureIndex];
    const pourcentageDistInfSurfSup = tableau91015.surfaces[keySup][distanceInferieureIndex];
    
    output += `À DL de ${distanceInferieure}m et surface max. de ${keyInf}m²: ${pourcentageDistInfSurfInf}%\n`;
    output += `À DL de ${distanceInferieure}m et surface max. de ${keySup === ">100" ? "plus de 100" : keySup}m²: ${pourcentageDistInfSurfSup}%\n`;
    
    const pourcentageEtape1 = pourcentageDistInfSurfSup + 
        ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
        (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup);
    
    output += `${pourcentageDistInfSurfSup} + (${surface.toFixed(2)} – ${surfaceInferieure}) / (${keySup === ">100" ? "Surface maximale du tableau" : surfaceSuperieure} – ${surfaceInferieure}) × (${pourcentageDistInfSurfInf} – ${pourcentageDistInfSurfSup}) = ${pourcentageEtape1.toFixed(3)} = ${pourcentageEtape1.toFixed(2)} %\n\n`;

    // ÉTAPE 2: Interpolation selon la DL supérieure
    output += "Étape 2: Interpolation selon la DL encadrante supérieure (" + distanceSuperieure + "m):\n";
    
    const pourcentageDistSupSurfInf = tableau91015.surfaces[keyInf][distanceSuperieureIndex];
    const pourcentageDistSupSurfSup = tableau91015.surfaces[keySup][distanceSuperieureIndex];
    
    output += `À DL de ${distanceSuperieure}m et surface max. de ${keyInf}m²: ${pourcentageDistSupSurfInf}%\n`;
    output += `À DL de ${distanceSuperieure}m et surface max. de ${keySup === ">100" ? "plus de 100" : keySup}m²: ${pourcentageDistSupSurfSup}%\n`;
    
    const pourcentageEtape2 = pourcentageDistSupSurfSup + 
        ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
        (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup);
    
    output += `${pourcentageDistSupSurfSup} + (${surface.toFixed(2)} – ${surfaceInferieure}) / (${keySup === ">100" ? "Surface maximale du tableau" : surfaceSuperieure} – ${surfaceInferieure}) × (${pourcentageDistSupSurfInf} – ${pourcentageDistSupSurfSup}) = ${pourcentageEtape2.toFixed(3)} = ${pourcentageEtape2.toFixed(2)} %\n\n`;
    
    // ÉTAPE 3: Interpolation finale
    output += "Étape 3: Interpolation selon les résultats obtenus des deux interpolations précédentes:\n";
    
    let pourcentageFinal = pourcentageEtape1 + 
        ((limitingDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageEtape2 - pourcentageEtape1);
        
    output += `${pourcentageEtape1.toFixed(2)} + (${limitingDistance.toFixed(2)} – ${distanceInferieure}) / (${distanceSuperieure} – ${distanceInferieure}) × (${pourcentageEtape2.toFixed(2)} – ${pourcentageEtape1.toFixed(2)}) = ${pourcentageFinal.toFixed(2)} %\n`;
    
    // Vérifier si on applique la formule spéciale pour les grandes surfaces
    if (surface > surfacesDisponibles[surfacesDisponibles.length - 1] && limitingDistance >= 1.2) {
        const valeurFormule = Math.pow(limitingDistance, 2);
        output += `\nFormule spéciale pour grande surface (>100 m²) avec DL ≥ 1,2 m: DL² = ${limitingDistance.toFixed(2)}² = ${valeurFormule.toFixed(2)}%\n`;
        pourcentageFinal = valeurFormule;
    }
    
    // Si nécessaire, appliquer la majoration
    if (sprinklersOption === "complete" || glassBrick) {
        const pourcentageMajore = Math.min(100, pourcentageFinal * 2);
        output += `\nMajoration (×2) pour ${sprinklersOption === "complete" ? "gicleurs" : "briques de verre/verre armé"}: ${pourcentageFinal.toFixed(2)}% × 2 = ${pourcentageMajore.toFixed(2)}%\n`;
    }
    
    return output;
}

function copyToClipboard(elementId) {
    let text = "";
    
    // Déterminer quelle méthode utiliser
    if (elementId === 'cnb-result') {
        text = formatCNBCalculationSteps();
    } else if (elementId === 'method91014-result') {
        text = format91014CalculationSteps();
    } else if (elementId === 'method91015-result') {
        text = format91015CalculationSteps();
    } else {
        // Fallback au comportement d'origine si l'ID n'est pas reconnu
        const element = document.getElementById(elementId);
        text = element.innerText;
    }
    
    // Méthode 1: Utiliser l'API Clipboard avec fallback
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text)
            .then(showCopiedFeedback)
            .catch(err => {
                console.error('Erreur Clipboard API:', err);
                fallbackCopyMethod(text, showCopiedFeedback);
            });
    } else {
        // Méthode 2: Fallback pour les contextes non-sécurisés ou navigateurs plus anciens
        fallbackCopyMethod(text, showCopiedFeedback);
    }
    
    function showCopiedFeedback() {
        // Obtenir l'ID du bouton
        let buttonId;
        if (elementId.startsWith('method')) {
            buttonId = elementId.split('-')[0].replace('method', '');
        } else {
            buttonId = elementId.split('-')[0];
        }
        
        const copyButton = document.getElementById(`copy_${buttonId}`);
        const originalButtonText = copyButton.innerHTML;
        copyButton.innerHTML = "✓ Copié!";
        setTimeout(() => {
            copyButton.innerHTML = originalButtonText;
        }, 2000);
    }
    
    function fallbackCopyMethod(text, callback) {
        // Créer un élément textarea temporaire
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Rendre l'élément invisible mais présent dans le DOM
        textArea.style.position = "fixed";
        textArea.style.opacity = 0;
        document.body.appendChild(textArea);
        
        // Sélectionner et copier le texte
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                callback();
            } else {
                console.error('La copie a échoué');
            }
        } catch (err) {
            console.error('Erreur lors de la copie:', err);
        }
        
        // Nettoyer
        document.body.removeChild(textArea);
    }
}
